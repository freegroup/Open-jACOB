/*******************************************************************************
 *    This file is part of Open-jACOB
 *    Copyright (C) 2005-2006 Tarragon GmbH
 * 
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; version 2 of the License.
 * 
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 * 
 *    You should have received a copy of the GNU General Public License     
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  
 *    USA
 *******************************************************************************/

package de.tif.jacob.core.data.impl.sql;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import de.tif.jacob.core.Context;
import de.tif.jacob.screen.ILongLastingOperation;

/**
 * @author Andreas Sonntag
 * 
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
class WrapperStatement implements Statement, ILongLastingOperation
{
  static public transient final String RCS_ID = "$Id: WrapperStatement.java,v 1.4 2011/01/17 08:08:03 freegroup Exp $";
  static public transient final String RCS_REV = "$Revision: 1.4 $";
  
  private Context context;
  protected WrapperConnection connection;
	protected Statement embedded;

	WrapperStatement(WrapperConnection connection, Statement embedded)
	{
		this.connection = connection;
		this.embedded = embedded;
		this.context = Context.getCurrent();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Connection#close()
	 */
	public void close() throws SQLException
	{
		// already closed?
		if (this.embedded == null)
			return;

		this.embedded.close();
		this.embedded = null;
		this.connection = null;
	}

	void checkClosed() throws SQLException
	{
		if (this.embedded == null)
			throw new SQLException("Statement is closed");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#addBatch(java.lang.String)
	 */
	public void addBatch(String sql) throws SQLException
	{
		checkClosed();
		this.embedded.addBatch(sql);
	}

	public boolean isClosed() throws SQLException
  {
    return embedded.isClosed();
  }

  public boolean isPoolable() throws SQLException
  {
    checkClosed();
    return embedded.isPoolable();
  }

  public boolean isWrapperFor(Class< ? > iface) throws SQLException
  {
    checkClosed();
    return embedded.isWrapperFor(iface);
  }

  public void setPoolable(boolean poolable) throws SQLException
  {
    checkClosed();
    embedded.setPoolable(poolable);
  }

  public <T> T unwrap(Class<T> iface) throws SQLException
  {
    checkClosed();
    return embedded.unwrap(iface);
  }

  /*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#cancel()
	 */
	public void cancel() throws SQLException
	{
		checkClosed();
		this.embedded.cancel();
	}

	/* (non-Javadoc)
	 * @see de.tif.jacob.screen.ILongLastingOperation#tryToCancel()
	 */
	public boolean tryToCancel() throws Exception
  {
    try
    {
      cancel();
      return true;
    }
    catch (SQLException ex)
    {
      if (SQL.logger.isWarnEnabled())
        SQL.logger.warn("Statement cancellation failed: " + ex.toString());
      throw ex;
    }
  }
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#clearBatch()
	 */
	public void clearBatch() throws SQLException
	{
		checkClosed();
		this.embedded.clearBatch();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#clearWarnings()
	 */
	public void clearWarnings() throws SQLException
	{
		checkClosed();
		this.embedded.clearWarnings();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#execute(java.lang.String, int)
	 */
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
	{
		checkClosed();
		return this.embedded.execute(sql, autoGeneratedKeys);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#execute(java.lang.String, int[])
	 */
	public boolean execute(String sql, int[] columnIndexes) throws SQLException
	{
		checkClosed();
		return this.embedded.execute(sql, columnIndexes);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#execute(java.lang.String, java.lang.String[])
	 */
	public boolean execute(String sql, String[] columnNames) throws SQLException
	{
		checkClosed();
		return this.embedded.execute(sql, columnNames);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#execute(java.lang.String)
	 */
	public boolean execute(String sql) throws SQLException
	{
		checkClosed();

		if (SQL.logger.isDebugEnabled())
			SQL.logger.debug("SQL: " + sql);

		long start = System.currentTimeMillis();
    try
    {
      boolean result = this.embedded.execute(sql);
      SQLMonitor.log(SQLMonitor.OTHER_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeBatch()
	 */
	public int[] executeBatch() throws SQLException
	{
		checkClosed();
		return this.embedded.executeBatch();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeQuery(java.lang.String)
	 */
	public ResultSet executeQuery(String sql) throws SQLException
	{
		checkClosed();
    
    if (SQL.logger.isDebugEnabled())
      SQL.logger.debug("SQLQuery: " + sql);
    
    long start = System.currentTimeMillis();
    try
    {
      ResultSet result = this.embedded.executeQuery(sql);
      SQLMonitor.log(SQLMonitor.QUERY_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int)
	 */
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
  {
    checkClosed();

    if (SQL.logger.isDebugEnabled())
      SQL.logger.debug("SQL: " + sql);

    long start = System.currentTimeMillis();
    try
    {
      int result = this.embedded.executeUpdate(sql, autoGeneratedKeys);
      SQLMonitor.log(SQLMonitor.UPDATE_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
  }

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int[])
	 */
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
	{
		checkClosed();

		if (SQL.logger.isDebugEnabled())
      SQL.logger.debug("SQL: " + sql);

		long start = System.currentTimeMillis();
    try
    {
      int result = this.embedded.executeUpdate(sql, columnIndexes);
      SQLMonitor.log(SQLMonitor.UPDATE_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeUpdate(java.lang.String,
	 *      java.lang.String[])
	 */
	public int executeUpdate(String sql, String[] columnNames) throws SQLException
	{
		checkClosed();

		if (SQL.logger.isDebugEnabled())
      SQL.logger.debug("SQL: " + sql);

		long start = System.currentTimeMillis();
    try
    {
      int result = this.embedded.executeUpdate(sql, columnNames);
      SQLMonitor.log(SQLMonitor.UPDATE_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#executeUpdate(java.lang.String)
	 */
	public int executeUpdate(String sql) throws SQLException
	{
		checkClosed();

		if (SQL.logger.isDebugEnabled())
      SQL.logger.debug("SQL: " + sql);

		long start = System.currentTimeMillis();
    try
    {
      int result = this.embedded.executeUpdate(sql);
      SQLMonitor.log(SQLMonitor.UPDATE_LOG_TYPE, start, this.connection.getDataSource(), sql);
      return result;
    }
    catch (SQLException e)
    {
      // rethrow the exception and add the SQL statement to the exception
      throw new de.tif.jacob.core.exception.SQLException(this.connection.getDataSource(), e, sql);
    }
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getConnection()
	 */
	public Connection getConnection() throws SQLException
	{
		checkClosed();
		return this.connection;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getFetchDirection()
	 */
	public int getFetchDirection() throws SQLException
	{
		checkClosed();
		return this.embedded.getFetchDirection();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getFetchSize()
	 */
	public int getFetchSize() throws SQLException
	{
		checkClosed();
		return this.embedded.getFetchSize();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getGeneratedKeys()
	 */
	public ResultSet getGeneratedKeys() throws SQLException
	{
		checkClosed();
		return this.embedded.getGeneratedKeys();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getMaxFieldSize()
	 */
	public int getMaxFieldSize() throws SQLException
	{
		checkClosed();
		return this.embedded.getMaxFieldSize();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getMaxRows()
	 */
	public int getMaxRows() throws SQLException
	{
		checkClosed();
		return this.embedded.getMaxRows();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getMoreResults()
	 */
	public boolean getMoreResults() throws SQLException
	{
		checkClosed();
		return this.embedded.getMoreResults();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getMoreResults(int)
	 */
	public boolean getMoreResults(int current) throws SQLException
	{
		checkClosed();
		return this.embedded.getMoreResults(current);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getQueryTimeout()
	 */
	public int getQueryTimeout() throws SQLException
	{
		checkClosed();
		return this.embedded.getQueryTimeout();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getResultSet()
	 */
	public ResultSet getResultSet() throws SQLException
	{
		checkClosed();
		return this.embedded.getResultSet();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getResultSetConcurrency()
	 */
	public int getResultSetConcurrency() throws SQLException
	{
		checkClosed();
		return this.embedded.getResultSetConcurrency();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getResultSetHoldability()
	 */
	public int getResultSetHoldability() throws SQLException
	{
		checkClosed();
		return this.embedded.getResultSetHoldability();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getResultSetType()
	 */
	public int getResultSetType() throws SQLException
	{
		checkClosed();
		return this.embedded.getResultSetType();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getUpdateCount()
	 */
	public int getUpdateCount() throws SQLException
	{
		checkClosed();
		return this.embedded.getUpdateCount();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#getWarnings()
	 */
	public SQLWarning getWarnings() throws SQLException
	{
		checkClosed();
		return this.embedded.getWarnings();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setCursorName(java.lang.String)
	 */
	public void setCursorName(String name) throws SQLException
	{
		checkClosed();
		this.embedded.setCursorName(name);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setEscapeProcessing(boolean)
	 */
	public void setEscapeProcessing(boolean enable) throws SQLException
	{
		checkClosed();
		this.embedded.setEscapeProcessing(enable);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setFetchDirection(int)
	 */
	public void setFetchDirection(int direction) throws SQLException
	{
		checkClosed();
		this.embedded.setFetchDirection(direction);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setFetchSize(int)
	 */
	public void setFetchSize(int rows) throws SQLException
	{
		checkClosed();
		this.embedded.setFetchSize(rows);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setMaxFieldSize(int)
	 */
	public void setMaxFieldSize(int max) throws SQLException
	{
		checkClosed();
		this.embedded.setMaxFieldSize(max);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setMaxRows(int)
	 */
	public void setMaxRows(int max) throws SQLException
	{
		checkClosed();
		this.embedded.setMaxRows(max);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.Statement#setQueryTimeout(int)
	 */
	public void setQueryTimeout(int seconds) throws SQLException
	{
		checkClosed();
		this.embedded.setQueryTimeout(seconds);
	}

}
