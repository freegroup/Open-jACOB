'NAME = "CallTest"
'TYPE = 0
'TEMPLATE = "Sub CallTest()"
'TEXT = [[


Sub CallTest()
Dim bres As Boolean
bres = True

End Sub
























































































































































































































































































































































']]
'NAME = "CallPreUpdate"
'TYPE = 0
'TEMPLATE = "Function CallPreUpdate() As Boolean"
'TEXT = [[

'*****************************************************************************
'Script:       CallPreUpdate
'Purpose:      Business rules that are executed before a call is updated.
'*****************************************************************************

Function AccessAllowed( iApp As Application, iCallGroup As SGroup) As Boolean
Dim iTable As DBTable
Dim iNetwork As DBNetwork

	If (InStr( iApp.GetUserGroups, "CQ_PM" ) > 0 ) Or _
		(InStr( iApp.GetUserGroups, "CQ_ADMIN" ) > 0 ) Or _
		(InStr( iApp.GetUserGroups, "CQ_AGENT" ) > 0 ) Or _
		(InStr( iApp.GetUserGroups, "CQ_SDADMIN" ) > 0 )Then
		AccessAllowed = True
		Exit Function
	End If
	Set iNetwork = iApp.ContextNetwork

	Set iTable = iNetwork.GetTable( "groupmember" )
	iTable.Clear
	iTable.QBEClear
    iTable.QBESetValue "employeegroup", iApp.CurrentUserKey
    iTable.QBESetValue "workgroupgroup", iCallGroup.GetCurrentRecord.GetValue("workgroupcall")
    iTable.QBESetValue "accessallowed", "lesen/schreiben"
	iTable.Search
	If iTable.RecordCount >0 Then
		AccessAllowed = True
	Else
		AccessAllowed = False
	End If
End Function
'-------------------------------
Function CallPreUpdate() As Boolean
Dim iApp As Application
Dim iFocus As SFocus
Dim iForm As SForm
Dim iCallRec As DBRecord
Dim dInterval As Date
Dim lTimeToClose As Long
Dim iCallGroup As SGroup
Dim nGroupMode As Integer
'END   modifiaction by Jacek Margos
Dim iNetwork As DBNetwork
Dim iUserTbl As DBTable
Dim sUserKey As String
Dim iWkgpTbl As DBTable
Dim sWkgpKey As String
Dim iNMTbl As DBTable
Dim lMNRecs As Long
Dim sRoles As String
Dim sControl As String
Dim iWorkgroupTable As DBTable
Dim sIsConference As String
Dim sWorkgroupPhone As String
Const ADMIN_ROLE = "CQ_ADMIN"  ' must be uppercase
Const SEPARATOR = ","
' END   modifications by Jacek Margos


    On Error GoTo callpreupdate_error_handler
    '-------------------------------------------------

    Set iApp = GetApp
	Err.Number = 0
    Set iFocus = iApp.ContextFocus()
	Set iCallRec = iApp.ContextRecord

	Set iCallGroup = iApp.ContextGroup()
	nGroupMode = iCallGroup.Mode()
	If nGroupMode = MODE_FILLED Then
' Check ob Änderung erlaubt ist
			If AccessAllowed( iApp, iCallGroup) Then
				iCallGroup.Change
	   	   		If iCallRec.GetValue("datecallconnected") = "" And iCallRec.GetValue("callstatus") = "Rückruf" Then
		   			iCallRec.SetValue "datecallconnected", "now"
		   		End If	
				CallPreUpdate = True
				Exit Function
			Else 
				iApp.UserMsg "Sie haben keinen schreibenden Zugriff auf diese Meldung",ebExclamation
				CallPreUpdate = False
				Exit Function
			End If
	ElseIf nGroupMode = MODE_MULTISELECT _
	    Or nGroupMode = MODE_MULTIUPDATE Then
		' no checks are being performed
		' and the function will not be invoked
		' for multiupdate
		CallPreUpdate = True
		Exit Function
	ElseIf nGroupMode = MODE_UPDATE _
	    Or nGroupMode = MODE_NEW Then
			' go and make the job
	Else
		' should never happen
		' but if the group's mode is not OK
		CallPreUpdate = False
		Exit Function
	End If
	If iCallGroup.GetValue ("callCusttext") = "" Then
		iApp.UserMsg "Der Meldung muß einen Kundentext haben.", ebInformation
		CallPreUpdate = False
		Exit Function
	End If	
	If iCallGroup.GetValue ("callEstimateddone") = "" Then
		iApp.UserMsg "Sie müssen ein 'voraussicht. Bearbeitungsende' der Meldung angeben.", ebInformation
		CallPreUpdate = False
		Exit Function
	End If	

	If iCallGroup.GetForeignKey("callWorkgroup") = "" Or  iCallGroup.GetForeignKey("callWorkgroup") = "NULL"	Then
		iApp.UserMsg "Der Meldung muß ein AK zugewiesen sein.", ebInformation
		CallPreUpdate = False
		Exit Function
	Else
		If ( iCallGroup.GetCurrentRecord.GetValue("workgroupcall") <> iCallGroup.GetForeignKey("callWorkgroup")) Or nGroupMode = MODE_NEW Then
			sWkgpKey = iCallGroup.GetForeignKey("callWorkgroup")
		   Set iWorkgroupTable = iApp.ContextNetwork.GetTable("callworkgroup")
			sIsConference = iWorkgroupTable.GetValueWhere("groupconferencecall", "pkey", sWkgpKey)
			If sIsConference = "Ja" And iCallGroup.Mode= MODE_NEW Then
    			sWorkgroupPhone = iWorkgroupTable.GetValueWhere("phone", "pkey", sWkgpKey)

				If iCallRec.GetValue("mastercall_key") = "" Or iCallRec.GetValue("mastercall_key") = "NULL" Then
					iApp.UserMsg "Bitte starten Sie einen Gruppenruf mit der Nummer: " & sWorkgroupPhone, ebInformation,"Gruppenruf"
				Else
					iApp.UserMsg "Gruppenruf: Bitte benachrichtigen Sie den AK (Tel." & sWorkgroupPhone & ")" & Basic.Eoln$ & _
								 "oder rufen Sie den Service Desk (Tel. 47111) an und teilen Sie die Nummer der" & Basic.Eoln$ & _
							     "Untermeldung mit.	" ,ebInformation,"Gruppenruf"
				End If
				If iCallGroup.GetValue("callAction") = "" Then
					iCallGroup.SetValue "callAction", "Gruppenruf unter: " &  sWorkgroupPhone
				Else
		   			iCallGroup.SetValue "callAction", "Gruppenruf unter: " &  sWorkgroupPhone & " " & iCallGroup.GetValue("callAction")
				End If
			End If
		End If
	End If
    iFocus.ResetTimer
	
' Modifications rolled back - Jacek Margos
	CallPreUpdate = True
    Exit Function  

callpreupdate_error_handler:
	' BEGIN modification by Jacek Margos
	' a workaround - the MODE_MULTIUPDATE
	' generates Error 16031 in the QScript
	' while getting iApp.Context...
	' if the button firing the QScript is
	' of type ChangeUpdate
	If ( Err.Number And 32767 ) = 16031 Then
		CallPreUpdate = True
		Exit Function
	End If
	' END   modification by Jacek Margos
    iApp.UserMsg "CallPreUpdate error " & CStr(Err) & ": " & Error$
    CallPreUpdate = False
End Function






















































































































































































































































































































']]
'NAME = "CallNew"
'TYPE = 0
'TEMPLATE = "Function CallNew() As Boolean"
'TEXT = [[

'*****************************************************************************
'Script:       CallNew
'Purpose:      Business rules that are executed when a call is entered.
'Copyright:    Quintus Corporation, 1996
'*****************************************************************************
'Option explicit
 Public dDatecallconnected As Date
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

Global Const sNull = ""

Sub ClearField(iGroup As SGroup, sFieldname As String, sDefault As String)
Dim sGroupName As String 
	sGroupName =iGroup.GUIName(sFieldname)
	If sGroupName <> "" Then 
		iGroup.SetValue sGroupName, sDefault
	End If
End Sub
'----------------------------------------------------
Function CallNew() As Boolean
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iFocus As SFocus
Dim iForm As SForm
Dim iGroup As SGroup
Dim iCallRec As DBRecord
Dim iCustomerTable As DBTable
Dim iLocationTable As DBTable
Dim iProcessTable As DBTable
Dim sAgent As String
Dim sAgentKey As String
Dim sWorkgroup As String
Dim sWorkgroupKey As String
Dim sStatusField As String
Dim sStatus As String
Dim sToday As String
Dim sName As String
Dim sPhone As String

    On Error GoTo new_error_handler
    '-------------------------------------------------
    Set iApp = GetApp()
    Set iFocus = iApp.ContextFocus()
    Set iForm = iApp.ContextForm()
    Set iGroup = iApp.ContextGroup()
    Set iNetwork = iFocus.Network()
   'If iGroup.Mode = Mode_New And iGroup.GetValue("callProblem") <> "" Then		  ' falls irrtümlich   neu gedrückt wurde
   '		iApp.UserMsg "Die Meldungsmaske ist gefüllt." & Basic.Eoln$ & _
   '					"Es wird eine NEUE Meldung angelegt.",ebInformation, " Neue Meldung anlegen"
   '	End If
		
    ' Set the dates
    sToday = FormatDate(Now)
    iGroup.SetValue "callDatereported", sToday

    sStatusField = iGroup.GUIName("callstatus")
	sStatus = iGroup.GetValue(sStatusField)
    	' Clear out some fields that could have been set if a 
	    ' previous call was used as the base.  These fields are only
		' set for closed calls.
	   ClearField iGroup, "autoclosed", "Ja"
	   ClearField iGroup, "cclist", sNull
	   ClearField iGroup, "closedby_sd", "0"
	   ClearField iGroup, "closedtaskcount", "0"
	   ClearField iGroup, "coordinationtime", sNull
	   ClearField iGroup, "cti_phone", sNull
	   ClearField iGroup, "dateassigned", sNull
	   ClearField iGroup, "datecallbackreq", sNull
	   ClearField iGroup, "datecallconnected", sNull
	   ClearField iGroup, "dateclosed", sNull
	   ClearField iGroup, "datedocumented", sNull
	   ClearField iGroup, "datefirstcontact", sNull
	   ClearField iGroup, "dateowned", sNull
	   ClearField iGroup, "datereported", sNull
	   ClearField iGroup, "dateresolved", sNull
	   ClearField iGroup, "defaultcontract", "0"
	   ClearField iGroup, "forrwardbyphone", "0"
	   ClearField iGroup, "history", sNull
	   ClearField iGroup, "ksl", sNull
	   ClearField iGroup, "opentaskcount", "0"
	   ClearField iGroup, "origin", sNull
	  ' ClearField iGroup, "priority", "1-Normal"
	   ClearField iGroup, "sd_time", sNull
	   ClearField iGroup, "sl", sNull
	   ClearField iGroup, "totaltaskdoc", sNull
	   ClearField iGroup, "totaltasktimespent", sNull

    iGroup.SetValue sStatusField, "Durchgestellt"
    ' Set the Agent
    sAgent = CurrentUserName(iNetwork, "agent")
    sAgentKey = CurrentUserKey(iNetwork, "agent")
	If sAgent = "" Then
	  iApp.UserMsg "Sie sind kein Agent. Beschaffen Sie sich die entsprechenden Rechte beim Administrator"
	  CallNew = False
      Exit Function
	End If
	
    iGroup.SetForeignValue "callAgent", sAgent, sAgentKey

	' affected person
	  Set iCustomerTable = iNetwork.GetTable("customerint")
	If iCustomerTable.RecordCount = 1 Then
			sPhone=  iCustomerTable.GetRecord(0).GetValue("phonecorr")
			sName=  iCustomerTable.GetRecord(0).GetValue("fullname")
			sCustomerKey = iCustomerTable.GetRecord(0).GetValue("pkey")
			If iGroup.GetValue("CallAffectedperson") = "" Then
				iGroup.SetValue "CallAffectedperson",sName & " Tel: " & sPhone 
   			End If
		If iGroup.GetValue("callAcountingcodetext")	= "" Then
		   iGroup.SetValue "callAcountingcodetext", iCustomerTable.GetRecord(0).GetValue("accountingcodecorr") 
		End If
	  	Set iAffectedpersonTable = iNetwork.GetTable("affectedperson")
		If iAffectedpersonTable.RecordCount <> 1 Then
	  		 iAffectedpersonTable.CLear
			 iAffectedpersonTable.QBESetValue "pkey", sCustomerKey
			 iAffectedpersonTable.Search
			 iGroup.SetForeignValue "callAffectedpersonFkey", sName, sCustomerKey
		End If												    
    End If
	Set iProcessTable = iNetwork.GetTable("process")
	If iProcessTable.RecordCount <> 1 Then
	  	iProcessTable.CLear
		iProcessTable.QBESetValue "pkey", GetAppProfileValue(iNetwork,"process_key")
		iProcessTable.Search
	End If												    

   	' Set Date Connected
	If dDatecallconnected <> CDate("1.1.2000" )	And dDatecallconnected <> CDate("00:00:00")	 Then
		iGroup.SetValue "callDatecallconnected", cStr(dDatecallconnected  )	
		dDatecallconnected =CDate( "1.1.2000" )
	Else
		iGroup.SetValue "callDatecallconnected", iApp.ContextTable.DBNow
	End If
	CallNew = True
    Exit Function

new_error_handler:
    iApp.UserMsg "CallNew error " & CStr(Err) & ": " & Error$
	CallNew = False
End Function

'----------------------------------------------------------------






















































































































































































































































































































']]
'NAME = "CallUpdate"
'TYPE = 0
'TEMPLATE = "Function CallUpdate() As Boolean"
'TEXT = [[

'*****************************************************************************
'Script:       CallUpdate
'Purpose:      Business rules that are executed when a call is updated.
'Copyright:    Quintus Corporation, 1996
'*****************************************************************************
'Option Explicit

Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String
Public bAutoDocumented As Boolean
Public bSendFAX As Boolean
Public bFirstLevelCloseCall As Boolean
Public bNotifyCustomer As Boolean
Public bManuellSearch As Boolean
Public bWebQ As Boolean
Public bAcceptCall As Boolean

'----------------------------------------------------------------
Global Const STATUS = "callstatus"
Global Const sNull = ""
'----------------------------------------------------------------
Dim OldStatus As String, NewStatus As String


Sub FindSLKSL(iApp As Application, iNetwork As DBNetwork, iCallRec As DBRecord) 
Dim iCategoryTable As DBTable
Dim iProcessTable As DBTable
Dim iRoutingTable As DBTable
Dim iCustomerTable As DBTable
Dim iRoutingRecord As DBRecord
Dim sCategoryKey As String
Dim sCurrentCategoryKey As String
Dim sProcessKey As String
Dim sContractKey As String
Dim sCurrentContractKey As String
Dim sDefaultContractKey As String
Dim bHasContract As Boolean
Dim sAccountingcodeKey As String
Dim bSuccessfull As Boolean
Dim bSetDefaultContract As Boolean
Dim bSite66Contract As Boolean
Dim bFinish As Boolean
Dim iTable As DBTable
Dim sSL As String
Dim sKSL As String

On Error GoTo Error_handler

	If Not ( iCallRec.HasChanged("categorycall") Or iCallRec.HasChanged("accountingcode_key") Or _
             iCallRec.HasChanged("process_key")) Then Exit Sub

	' First get the table from the network, and see if we have a record selected.
	Set iCustomerTable = iNetwork.GetTable("customerint")

	If iCustomerTable.RecordCount = 1 Then
		If iCustomerTable.Getrecord(0).GetValue("emplsite_key")="66" Then
			
		   bSite66Contract= True	
		Else
			bSite66Contract=False
		End If
	Else 
		bSite66Contract = False
    End If
	Set iCategoryTable = iNetwork.GetTable("category")
	sCategoryKey = iCallRec.GetValue("categorycall")
	sProcessKey = iCallRec.GetValue("process_key")
	' Den Vertrag über die Kostenstelle finden.
	' Wenn kein Vertrag vorhanden ist, den Standardvertrag nehmen
	sContractKey = ""
	bSetDefaultContract = False
	sAccountingcodeKey = iCallRec.GetValue("accountingcode_key")
	
	If sAccountingcodeKey <> "NULL" And sAccountingcodeKey <> "" Then
 		' automatisches SQL erzeugt falschen Code statt where code = 'XXX' wird code ='''XXX''' erzeugt ( varchar als Key :-(
		'	sContractKey = iNetwork.GetTable("accountingcode").GetValueWhere("contract_key","code",sAccountingcodeKey)
   	     Set iTable = iApp.ContextNetwork.GetTable("accountingcode")
		 iTable.Clear
		 iTable.QBEClear
		 iTable.QBESetValue "code", sAccountingcodeKey
		 iTable.Search	
		 If iTable.RecordCount = 1 Then
   		   sContractKey = iTable.GetRecord(0).GetValue("contract_key")
		 End If
	End If
	bHasContract = True
	If sContractKey = "NULL" Or sContractKey = "" Then
	   bSetDefaultContract = True	
	   bHasContract = False	
	End If
	sDefaultContractKey = GetAppProfileValue(iNetwork, "contract_key") ' Standardvertrag	
	

'  Suchen des Routingsatzes
	
	Set iRoutingTable = iNetwork.GetTable("contractsl")
	sCurrentCategoryKey = sCategoryKey
	If bHasContract Then
		sCurrentContractKey = sContractKey
	Else
		sCurrentContractKey = sDefaultContractKey
	End If
	bSuccessfull = False
	bFinish = False
	Do
		iRoutingTable.Clear
 		iRoutingTable.QBEClear
  		iRoutingTable.QBESetValue "category_key", sCurrentCategoryKey
		iRoutingTable.QBESetValue "process_key", sProcessKey
		iRoutingTable.QBESetValue "contract_key", sCurrentContractKey
		iRoutingTable.Search
	
		If iRoutingTable.RecordCount > 0 Then
		'We have a  record Lets Select selected.
			Set iRoutingRecord  = iRoutingTable.GetRecord(0)
			bSuccessfull= True
		End If
		'Wenn keine Abdeckung schauen ob Vatergewerk Abdeckung hat
		If Not bSuccessfull Then
			sCurrentCategoryKey =iCategoryTable.GetValueWhere("parentcategory_key","pkey",sCurrentCategoryKey)
			If (sCurrentCategoryKey = "" Or sCurrentCategoryKey ="NULL") Then	'Ebene 1 des Gewerkebaums erreicht
				If bHasContract Then ' wenn nicht der spezielle Vertrag vielleicht der Standardvertrag
					bHasContract = False
					bSetDefaultContract = True
					sCurrentCategoryKey = sCategoryKey
					sCurrentContractKey =sDefaultContractKey	
				Else
					bFinish = True ' Nichts gefunden :-(
				End If
			End If
		End If 
	Loop Until bSuccessfull Or bFinish
	If bSuccessfull Then
		'We have a single record selected.  Let's link.
	   	sSL = iRoutingRecord.GetValue("sl")
		sKSL = iRoutingRecord.GetValue("ksl")
	Else
	   	sSL = ""
		sKSL = ""
    End If
   	iCallRec.SetValue "sl", sSL
   	iCallRec.SetValue "ksl",sKSL


GoTo Exit_Sub
Error_handler:
    iApp.UserMsg "FindSLKS error " & CStr(Err) & ": " & Error$

Exit_Sub:
' Clean up
Set iCategoryTable = Nothing
Set iProcessTable = Nothing
Set iRoutingTable = Nothing
Set iCustomerTable = Nothing
Set iRoutingRecord = Nothing

End Sub
'--------------------------------------------------------------------------------------------------------------
Function SetReadOnly(iApp As Application, iCallRec As DBRecord, sField As String, sMsg As String) As Boolean
Dim sOldKey As String
Dim sKey As String
Dim iGroupTAble As DBTable
On Error GoTo Error_handler
	SetReadOnly = True
   '	iF iCallRec.Mode = MODE_NEW Then Exit Function	
   '	If iCallRec.GetValue(sField) <> iCallRec.GetOldValue(sField) Then	
	  ' IRec.HasChanged() funktioniert nicht Problem: Fehler bei GetOldVAlue falls nicht vorhanden
	If iCallRec.HasChanged(sField) Then
		If sField ="workgroupcall" Then
		   sKey = iCallRec.GetVAlue("workgroupcall")
		   sOldKey = iCallRec.GetOldValue("workgroupcall")
		   Set iGroupTable = iApp.ContextNetwork.GetTAble("callworkgroup")
		   If ((iGroupTable.GetValueWhere("organization_key","pkey",skey) <> iGroupTable.GetValueWhere("organization_key","pkey",sOldKey) ) Or _
			  (iGroupTable.GetValueWhere("orgexternal_key","pkey",skey) <> iGroupTable.GetValueWhere("orgexternal_key","pkey",sOldKey) )) Or _
				(iApp.Name = "imsys" Or iApp.Name = "testimsys") Then
   		   		iApp.UserMsg "Änderung von " & sMsg & " ist nicht erlaubt.", ebInformation
   		   		SetReadOnly = false
   		   End If
		Else
	   		iApp.UserMsg "Änderung von " & sMsg & " ist nicht erlaubt.", ebInformation
	   		SetReadOnly = false
		End If
	End If
Set iGroupTable = Nothing
Error_handler:
End Function

Function CheckValueChange(iApp As Application, iCallRec As DBRecord) As Boolean
' Get the old and new status field values.  Based on these, enforce
' the state change rules.
' This rule makes no assumptions about GUI state.
Dim sStatus As String
Dim dDatecallconnected As Date
Dim dNow As Date
Dim isOK As Boolean
	CheckValueChange =False
	isOK = True
	sStatus = iCallRec.GetValue("callstatus")
	If iCallRec.Mode = 3 Then 'MODE_NEW  ' Set sd_time
		If iCallRec.GetValue("datecallconnected") <> ""	Then
	   		dDatecallconnected=iCallRec.GetValueAsDate("datecallconnected") 
			dNow =iCallRec.GetValue( "datereported") ' iApp.ContextNetwork.GetTable("appprofile").DBNow
			iCallRec.SetValue "sd_time" ,  iApp.SecondsToInterval( int ( iApp.BusinessInterval(dDatecallconnected,dNow)	) )
		Else
			iCallRec.SetValue "datecallconnected" , iCallRec.GetValue( "datereported")
			iCallRec.SetValue "sd_time" ,"00:00:00"
		End If
	End If	
    Select Case sStatus

    Case "Verworfen"

    Case "Rückruf"

    Case "Durchgestellt"

    Case "AK zugewiesen"
	  If iCallRec.Mode <> 3 Then 'MODE_NEW	
	  	isOK =SetReadOnly( iApp, iCallRec, "agentcall", "Agent")
	  End If

    Case "Fehlgeroutet"
	  isOK =SetReadOnly( iApp, iCallRec, "agentcall","Agent")

    Case "Angenommen" 
	  isOK =SetReadOnly( iApp, iCallRec, "agentcall","Agent")

    Case  "Fertig gemeldet", "Dokumentiert", "Geschlossen"
	  isOK =SetReadOnly( iApp, iCallRec, "workgroupcall", "Auftragskoordinator")
	  isOK = isOK And SetReadOnly( iApp, iCallRec, "agentcall","Agent")
    End Select
	CheckValueChange =	isOK
	If iCallRec.HasChanged("workgroupcall") And bManuellSearch Then
		iCallRec.SetValue "routinginfo", "von Hand geroutet"	
		bManuellSearch = False
	End If
End Function

'----------------------------------------------------------------
Function LinkThroughTable(iNetwork As DBNetwork, iCallRec As DBRecord, sTableName As String, sFieldName As String) As Boolean

' Try to link the records through the table.  Could already have selected
' a record, but with the workings of the GUI, not have the foreign field
' filled in for the call.

Dim iRec As DBRecord
Dim iTable As DBTable

	Set iTable = iNetwork.GetTable(sTableName)
	LinkThroughTable = False
	If iTable.RecordCount = 1 Then
		iCallRec.SetValue sFieldName, iTable.GetRecord(0).GetKeyValue
		LinkThroughTable = True
	End If
Set iRec = Nothing
Set iTable = Nothing
End Function
'----------------------------------------------------------------
Function CheckCallDocumented(iApp As Application, iNetwork As DBNetwork, iCallRec As DBRecord, sErrorMsg As String) As Boolean
Dim sCoordinationtime As String
Dim  isOK As Boolean
Dim iObjectRec As DBRecord	
Dim sObjCategoryKey As String
Dim sClosedTasks As String
Dim iSearchNetwork As DBNetwork
Dim iBrowser As DBBrowser
Dim iTaskTable As DBTable
Dim iCallduplicateTable As DBTable
Dim sCallID As String
Dim nOpenTaskCount As Integer
On Error GoTo Exit_Function

	CheckCallDocumented= True
	isOK = True	
	If iCallRec.GetValue("callstatus") <> "Dokumentiert" Then Exit Function
	'sCoordinationtime = iCallRec.GetValue("coordinationtime")

	'If sCoordinationtime = "" Then
	'	iApp.UserMsg " Sie müssen Ihren Koordinationsaufwand angeben um die Meldung zu dokumentieren", ebInformation
	'	isOK = False
	'End If
 	Set iSearchNetwork = iApp.CreateNetwork( "q_task", "test" )	  ' mit  iApp.CreateNetwork( "q_task", "q_task" )  gab es Ärger	
 	Set iBrowser = iSearchNetwork.GetBrowser( "callduplicateBrowser" )
 	Set iCallduplicateTable = iSearchNetwork.GetTable( "callduplicate" )
 	iCallduplicateTable.Clear
  	sCallID = iCallRec.GetKeyValue
  	iCallduplicateTable.QBEClear
   	iCallduplicateTable.QBESetValue "mastercall_key", sCallID
   	iCallduplicateTable.QBESetValue "callstatus", "Rückruf|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen|Fertig gemeldet"
	iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
	If iBrowser.RecordCount	>0  Then
		sErrorMsg = "Es müssen erst alle Untermeldungen dokumentiert sein um die Meldung zu dokumentieren"
		isOK= False
		GoTo Exit_Function
	End If 
 	Set iTaskTable = iSearchNetwork.GetTable( "tasktable" )
 	iTaskTable.Clear
  	iTaskTable.QBEClear
   	iTaskTable.QBESetValue "calltask", sCallID
   	iTaskTable.QBESetValue "taskstatus", "Neu|Angelegt|Freigegeben|In Arbeit|Fertig gemeldet"
	iTaskTable.Search
	If iTaskTable.RecordCount	>0 Then
		sErrorMsg =  "Es müssen erst alle Aufträge dokumentiert sein um die Meldung zu dokumentieren"
		isOK= False
		GoTo Exit_Function
	End If 
  '	If (Not iCallRec.HasLinkedRecord("object")) And  (val(sClosedTasks)>0)   Then
   '		iApp.UserMsg "Sie müssen ein Objekt angeben um die Meldung zu dokumentieren," & Basic.Eoln$ & _
   '						"damit die vorhandenen Aufträge abgerechnet werden können.", ebInformation
   '		isOK = False
   '	Else 
		If iCallRec.HasLinkedRecord("object") Then
	   		Set iObjectRec = iCallRec.GetLinkedRecord("object") 
	   		sObjCategoryKey	= iObjectRec.GetValue("objectcategory_key")
   '			If (val(sClosedTasks)>0) And (iObjectRec.GetValue("objstatus")= "außer Betrieb" ) Then 
   '			 		iApp.UserMsg "Auf ein Objekt im Status 'Außer Betrieb' können keine Aufträge abgerechnet werden." , ebInformation
   '			  		isOK = False
   '			End If

	   		If 	sObjCategoryKey = "" Or sObjCategoryKey="NULL" Then
				If GetAppProfileValue(iNetwork,"checkobjcategory") ="1" Then
			 		sErrorMsg = "Sie müssen dem Objekt ein Gewerk zuordnen um die Meldung zu dokumentieren"
			  		isOK = False
				End If
	   		End If
		End If
	'End If
	If Not iCallRec.HasLinkedRecord("category") Then
		sErrorMsg = " Sie müssen ein Gewerk angeben um die Meldung zu dokumentieren"
		isOK = False
	Else 
		' Gültigkeit des Gewerks spielt keine Rolle mehr
	   '	sCategoryType	= iCallRec.GetLinkedRecord("category").GetValue("categorystatus")
	   '	If 	sCategoryType <> "Gültig" Then
	   '		iApp.UserMsg " Das zugeordnete Gewerk der Meldung ist nicht gültig", ebInformation
	   '		isOK = False
	   '	End If
	End If
Exit_Function:
	Set iTaskTable = Nothing
	Set iBrowser = Nothing
	Set iSearchNetwork = Nothing
 	Set iCallduplicateTable =Nothing
	CheckCallDocumented = isOK
End Function
'----------------------------------------------------------------
Function CheckCallLinks(iApp As Application, iNetwork As DBNetwork, iCallRec As DBRecord) As Boolean
' Check to make sure that tha call is linked to the tables that
' are required depending on the application.

Dim iContract As DBRecord
Dim iTable As DBTable
Dim iWebTable As DBTable
Dim iAffectedpersonTable As DBTable
Dim iWebRec As DBRecord
Dim iCustomerRec As DBRecord
Dim iAgentTable As DBTable
Dim iObjectTable AS DBTable
Dim sString As String
Dim sStatus As String
Dim lTimeToClose As Long
Dim lCommitment As Long
Dim iSearchNetwork As DBNetwork
Dim iBrowser As DBBrowser
Dim iTaskTable As DBTable
Dim iCallduplicateTable As DBTable
Dim sCallID As String
Dim nOpenTaskCount As Integer
Dim nOpenSubCalls As Integer
Dim nOpenTasks As Integer
Dim nTasks As Integer
Dim nTotalcoordsubcall As Long
Dim sDefaultExtSystemKey As String
Dim sDummy As String
Dim sOpenTasks As String
Dim sObjectkey As String
Dim sExtSystemKey As String
Dim sExtSystemName As String
Dim IsOK As Boolean
Dim bHasChangedsl_overdue As Boolean
Dim bHasChangeddate_sl_overdue As Boolean
Dim bHasOldsl_overdue As Boolean
Dim sOldsl_overdue As String
Dim bHasOlddate_sl_overdue As Boolean 
Dim sOlddate_sl_overdue As String
Dim sDate_sl_overdue As String
Dim sSl_overdue As String 
Dim sAgentkey As String
Dim sObjectPriority As String
Dim	sPhone As String
Dim sName As String
Dim sCustomerKey As String



	' We will reset only if we have an error, assume that everything is here.
	CheckCallLinks = True

' Check SL overdue
	bNotifyCustomer = False
	bHasChangedsl_overdue = False
	bHasChangeddate_sl_overdue= False
	bHasOldsl_overdue = False
	IsOK = True
	sOldsl_overdue =iCallRec.GetValue("sl_overdue")
	bHasOlddate_sl_overdue= False
	sOlddate_sl_overdue = iCallRec.GetValue("date_sl_overdue") 
	sDate_sl_overdue =iCallRec.GetValue("date_sl_overdue") 
	sSl_overdue	 = iCallRec.GetValue("sl_overdue")
	
	If iCallRec.HasChanged("sl_overdue") Then
		bHasChangedsl_overdue = True
		If iCallRec.HasOldValue("sl_overdue") Then
			 sOldsl_overdue = iCallRec.GetOldValue("sl_overdue")
			If sOldsl_overdue <> "" Then bHasOldsl_overdue = True		
		End If
   		If sOldsl_overdue = sSl_overdue Then bHasChangedsl_overdue = False
	End If 
	If iCallRec.HasChanged("date_sl_overdue") Then
		bHasChangeddate_sl_overdue = True
		If iCallRec.HasOldValue("date_sl_overdue") Then
		   sOlddate_sl_overdue = iCallRec.GetOldValue("date_sl_overdue")	
		   If sOlddate_sl_overdue <> "" Then bHasOlddate_sl_overdue = True
		End If
   		If sOlddate_sl_overdue = sDate_sl_overdue Then bHasChangeddate_sl_overdue = False
	End If 
	' Änderung nur im Status Angenommen
	If iCallRec.GetValue("sl") <> "" And (bHasChangedsl_overdue And iCallRec.GetValue("sl_overdue") <> "" )Then
     	If (cDate(Now()) > dateadd("s",iApp.IntervalToSeconds(iCallRec.GetValue("sl")),iCallRec.GetValue("datereported"))) Then
	   		iApp.UserMsg "Eine Verschiebung des Servicelevels ist nach dem Ablauf der Frist nicht mehr möglich.", ebInformation
		iCallRec.SetValue "date_sl_overdue", sOlddate_sl_overdue
		iCallRec.SetValue "sl_overdue", sOldsl_overdue
		sSl_overdue =  sOldsl_overdue
		sDate_sl_overdue = sOlddate_sl_overdue
		IsOK = False
		End If
	Else
		If iCallRec.GetValue("sl") = "" And iCallRec.HasChanged("sl_overdue") And (iCallRec.GetValue("sl_overdue") <> "" ) Then
	   		iApp.UserMsg "Eine Verschiebung des Servicelevels ist nicht nötig da kein SL definiert ist.", ebInformation
		iCallRec.SetValue "date_sl_overdue", sOlddate_sl_overdue
		iCallRec.SetValue "sl_overdue", sOldsl_overdue
		sSl_overdue =  sOldsl_overdue
		sDate_sl_overdue = sOlddate_sl_overdue
		IsOK = False
		End If
	End If 
    If (bHasChangeddate_sl_overdue Or bHasChangedsl_overdue) And iCallRec.GetValue("callstatus")<> "Angenommen" Then
		iApp.UserMsg "SL darf nur einmal im Status 'Angenommen' verschoben werden.", ebCritical
		iCallRec.SetValue "date_sl_overdue", sOlddate_sl_overdue
		iCallRec.SetValue "sl_overdue", sOldsl_overdue
		IsOK = False
	Else
     If (bHasChangeddate_sl_overdue And bHasOlddate_sl_overdue) Or (bHasChangedsl_overdue And bHasOldsl_overdue) Then
		iApp.UserMsg "SL darf nur einmal im Status 'Angenommen' verschoben werden.", ebCritical
		iCallRec.SetValue "date_sl_overdue", sOlddate_sl_overdue
		iCallRec.SetValue "sl_overdue", sOldsl_overdue
		sSl_overdue =  sOldsl_overdue
		sDate_sl_overdue = sOlddate_sl_overdue
		IsOK = False
	 End If 

   	 If ((sSl_overdue = "") And  (sDate_sl_overdue<> ""))  Then
		iApp.UserMsg "Sie müssen eine Begründung für den Verzug des Service Levels eingeben", ebInformation
		CheckCallLinks = False
		IsOK = False
		Exit Function
   	 End If

     If ((sSl_overdue <> "") And (sDate_sl_overdue = "")) Then
		iApp.UserMsg "Ene Begründung ohne Datum der Wiederherstellung ist unzulässig", ebInformation
		CheckCallLinks = False
		IsOK = False
		Exit Function
	 End If
	If bHasChangeddate_sl_overdue And IsOK And sDate_sl_overdue <> "" Then
   		 If (CDate(sDate_sl_overdue) < Now()) Then
	   	    iApp.UserMsg "Der Verzug des Service Levels kann nicht in der Vergangenheit liegen", ebInformation
	   		iCallRec.SetValue "date_sl_overdue", sOlddate_sl_overdue
	  		iCallRec.SetValue "sl_overdue", sOldsl_overdue
	   		sSl_overdue =  sOldsl_overdue
			sDate_sl_overdue = sOlddate_sl_overdue
	   		IsOK = False
   	 	 End If
   	 End If

    If bHasChangedsl_overdue And IsOK Then bNotifyCustomer = True
	End If
	' Now we fill in the links that we have.  To do this we first check it a table is 
	' in our network.  If so then it is a part of this focus, so we will link the table
	' to our call.

	' First look for the type of product/category associated with this call.  Here is where 
	' another table could be substituted for a new application.

	' BEGIN modification by Jacek Margos
	' we have included the table "product" into the design
	' we do not link the product with the call (like CustQ)
	' but the category
	' the following code has been commented out


	If iNetwork.HasTable("category") Then
        ' We need to make sure we have an category.
        If Not(iCallRec.HasLinkedRecord("category")) And _
		   Not(LinkThroughTable(iNetwork,iCallRec,"category","categorycall")) Then
                iApp.UserMsg "Für diese Meldung müssen Sie erst ein Gewerk auswählen"
                CheckCallLinks = False
       	        Exit Function
		End If
	End If
'Tätigkeit ist Pflicht
	If iNetwork.HasTable("process") Then
        ' We need to make sure we have an category.
        If Not(iCallRec.HasLinkedRecord("process")) And _
		   Not(LinkThroughTable(iNetwork,iCallRec,"process","process_key")) Then
                    iApp.UserMsg "Für diese Meldung müssen Sie erst ein Tätigkeit auswählen"
                CheckCallLinks = False
       	        Exit Function
		End If
	End If
' Ort ist nur Pflicht wenn in Tätigkeit und Gewerk angegeben
	If iCallRec.GetLinkedRecord("process").GetValue("locationrequired") = "Ja" And _
	   iCallRec.GetLinkedRecord("category").GetValue("locationrequired") = "Ja"	 Then
        ' We need to make sure we have alocation.
        If Not(iCallRec.HasLinkedRecord("location")) And _
		   Not(LinkThroughTable(iNetwork,iCallRec,"location","location_key")) And _
			 (iCallRec.Mode = MODE_NEW ) Then
                    iApp.UserMsg "Für diese Meldung müssen Sie erst ein Meldungsort angeben"
                CheckCallLinks = False
       	        Exit Function
		Else
  	   		If iCallRec.HasChanged( "location_key" ) Then
				sDummy = iCallRec.GetValue("location_key")
				If iCallRec.GetTable.InDatabase("location_key",sDummy) Then
		   			iApp.UserMsg "Es muß immer ein NEUER Störungsort angegegeben werden. ",ebInformation, "Störungsort nicht eindeutig in der Datenbank"
                	CheckCallLinks = False
       	        	Exit Function
				End If
			End If	
		End If	
	End If
	If iCallRec.GetLinkedRecord("process").GetValue("considerpriority") = 1 And iCallRec.Mode= MODE_NEW Then
		Set iObjectTable = iNetwork.GetTable("object")
			If iObjectTable.RecordCount = 1 Then
	    		sObjectPriority = iObjectTable.Getrecord(0).GetValue("priority")
				If 	iObjectTable.MapEnumStrToInt("priority",iCallRec.GetValue("priority")) < iObjectTable.MapEnumStrToInt("priority",sObjectPriority)	Then
					iCallRec.SetValue "priority", sObjectPriority
				End If
			End If		
	End If

	' Now we have to link to the person who made the call.  In some applications this is
	' a customer in others it is an employee.  Here also is where a modification can
	' be made for a new application.


	If iNetwork.HasTable("customerint") Then
        If Not(iCallRec.HasLinkedRecord("customerint")) And _
		   Not(LinkThroughTable(iNetwork,iCallRec,"customerint","employeecall")) Then
				' Well there is a possibility that we are in WebQ.  If this is the case,
				' we have to check the webqauth table to get our value.  If we are not
				' in WebQ, then there won't be a webqauth table selected, and we will have
				' to error out of the update.


			If bWebQ Then
				' Link using the link in the WebQ record to the customer.
				iCallRec.SetValue "employeecall", iWebRec.GetValue("employeewebqauth")
			Else
		    iApp.UserMsg "Für diese Meldung müssen Sie erst einen Melder auswählen"	
    	        CheckCallLinks = False
        	    Exit Function
			End If
        End If

	   If iCallRec.Mode = MODE_NEW  Then 
			 ' Copy callback method from customer
			iCallRec.SetValue "callbackmethod", iNetwork.GetTable("customerint").GetValueWhere("communicatepref","pkey",iCallRec.GetValue("employeecall") )

			Set iCustomerRec = iCallRec.GetLinkedRecord("customerint") 
			' Wenn keine Untermeldung, dann prüfen, ob	betroffene Person gesetzt werden soll
			If (iCallRec.GetValue("affectedperson_key") ="NULL" Or  iCallRec.GetValue("affectedperson_key") ="") And iCallRec.GetValue("mastercall_key") ="" Then
				sPhone=  iCustomerRec.GetValue("phonecorr")
				sName=  iCustomerRec.GetValue("fullname")
				sCustomerKey = iCustomerRec.GetValue("pkey")
	  			Set iAffectedpersonTable = iNetwork.GetTable("affectedperson")
			    iAffectedpersonTable.CLear
			 	iAffectedpersonTable.QBESetValue "pkey", "=" & sCustomerKey
			    iAffectedpersonTable.Search
			    iCallRec.SetValue "affectedperson_key", sCustomerKey
				iCallRec.SetValue "affectedperson",sName & " Tel: " & sPhone 	
   			End If
			' Die Kostenstelle der Melders setzen, falls Sie leer ist.
			If iCallRec.GetValue("accountingcodetext")	= ""  Then
		   		iCallRec.SetValue "accountingcodetext", iCustomerRec.GetValue("accountingcodecorr") 
			End If
	   	End If

	End If

	' OK let's check for the agent link.  This is only going to be needed
	' when a call is created from WebQ.
	If Not(iCallRec.HasLinkedRecord("agent")) And bWebQ Then
		' Need the agent table so we can grap the record required...
		Select Case iWebRec.GetValue("usertype")
			Case "Kunde"
				' If we are a customer user type, then we need to assign this
				' call to the agent assigned to our user through the webqauth
				' record.
				iCallRec.SetValue "agentcall", iWebRec.GetValue("agentwebqauth")

			Case "Mitarbeiter"
				' This is a little more straight forward, The user we have is to 
				' be the agent, so set the link to the employee in the WebQ 
				' Authorization	record.
				iCallRec.SetValue "agentcall", iWebRec.GetValue("employeewebqauth")
		End Select
	Else
   	 ' Check to be sure that there is an agent.  If not, supply one
   	 	If iCallRec.GetValue("agentcall") = "" Then
     	     sAgentkey = CurrentUserKey(iNetwork, "agent")
			 If sAgentkey = "" Then	
			 	iApp.UserMsg "Sie sind kein Agent. Beschaffen Sie sich die entsprechenden Rechte beim Administrator"
                CheckCallLinks = False
                Exit Function
			 Else 
				iCallRec.SetValue "agentcall", sAgentkey
			 End If
 		 
    	End If

	End If
 
    ' Now deal with the status fields.  Different things can happen for a status.
    sStatus = iCallRec.GetValue("callstatus")

  	If sStatus = "Angenommen" And iCallRec.HasLinkedRecord("callworkgroup") And iCallRec.Haschanged("workgroupcall") And Not bAcceptCall Then
		iCallRec.SetValue "callstatus","AK zugewiesen"
		iCallRec.SetValue "dateowned",""
	End If
  	If sStatus = "Fertig gemeldet" or sStatus ="Verworfen" Then
		sOpenTasks = iCallRec.GetValue("opentaskcount")

        If  val(sOpenTasks) <> 0 Then
			If sStatus = "Fertig gemeldet" Then
            	iApp.UserMsg "Sie müssen erst alle assoziierten Aufträge fertig melden bevor Sie die Meldung fertig melden. " &_
					"Der Status war " & iCallRec.GetOldValue("callstatus")
			Else
            	iApp.UserMsg "Sie müssen erst alle assoziierten Aufträge fertig melden oder stornieren bevor Sie die Meldung stornieren. " &_
					"Der Status war " & iCallRec.GetOldValue("callstatus")
			End If
            CheckCallLinks = False
            Exit Function
        End If
		' Sub Calls checken

		Set iSearchNetwork = iApp.CreateNetwork( "q_taskcount", "q_taskcount" )
 		Set iBrowser = iSearchNetwork.GetBrowser( "callduplicateBrowser" )
   		Set iCallduplicateTable = iSearchNetwork.GetTable( "callduplicate" )
		iCallduplicateTable.Clear
		sCallID = iCallRec.GetKeyValue
   		iCallduplicateTable.QBEClear
   		iCallduplicateTable.QBESetValue "mastercall_key", sCallID
   		iCallduplicateTable.QBESetValue "callstatus", "Rückruf|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen"
		iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
		nOpenSubCalls = iBrowser.RecordCount

		Set iCallduplicateTable = Nothing
		Set iBrowser = Nothing
		Set iSearchNetwork = Nothing
		If nOpenSubCalls >0 Then
			If sStatus = "Fertig gemeldet" Then
            	iApp.UserMsg "Sie müssen erst alle assoziierten Untermeldungen fertig melden bevor Sie diese Meldung fertig melden. " &_
			   		"Der Status war " & iCallRec.GetOldValue("callstatus")
			Else
            	iApp.UserMsg "Sie müssen erst alle assoziierten Untermeldungen fertig melden oder stornieren bevor Sie diese Meldung stornieren. " &_
			   		"Der Status war " & iCallRec.GetOldValue("callstatus")
			End If
            CheckCallLinks = False
            Exit Function
        End If

    End If

	Set iTaskTable = Nothing
	Set iObjectTable = Nothing
	Set iBrowser = Nothing
	Set iSearchNetwork = Nothing
    ' If we are in WebQ, and creating a new record, set the origin to WebQ
    If bWebq And iCallRec.Mode = MODE_NEW Then iCallRec.SetValue "origin", "WebQ"


End Function
'--------------------------------------------------------

Function CheckCallStatusChange(iApp As Application, _
    iNetwork As DBNetwork, iCallTable As DBTable, _
    iCallRec As DBRecord) As Boolean
' Get the old and new status field values.  Based on these, enforce
' the state change rules.
' This rule makes no assumptions about GUI state.
Dim iCallWorkgroupRec As DBRecord
Dim dDateAssigned As Date
Dim dDateConnected As Date
Dim dDateDocumented As Date
Dim dCloseBy As Date
Dim sClosedBy As String
Dim lInterval As Long
Dim nSD_Time As Long
Dim isOK As Boolean
Dim sErrorMsg As String
	CheckCallStatusChange =False
	isOK = True
    If iCallRec.HasChanged(STATUS) Then
		If iCallRec.Mode = MODE_NEW Then
        	OldStatus = iCallRec.GetValue(STATUS)
        	NewStatus = iCallRec.GetValue(STATUS)
		Else
        	OldStatus = iCallRec.GetOldValue(STATUS)
        	NewStatus = iCallRec.GetValue(STATUS)
		End If
    Else
 	    If iCallRec.GetValue (STATUS) = "Geschlossen" Then
			iApp.UserMsg "Geschlossene Meldungen dürfen nicht mehr geändert werden.",ebCritical
			isOK =FALSE
		Else
			isOK =TRUE
    	End If
		CheckCallStatusChange =	isOK
    	Exit Function
    End If

    If OldStatus = "Geschlossen" Then
		iApp.UserMsg "Geschlossene Meldungen dürfen nicht mehr geändert werden.",ebCritical
		CheckCallStatusChange =	FALSE
    	Exit Function
    End If

    Select Case NewStatus


    Case "Rückruf"
        If OldStatus = sNull Then
            	iCallRec.SetValue "dateclosed", "now"
				 
    			iCallRec.SetValue "agentcall", CurrentUserKey(iNetwork, "agent")

		Else
			isOK = False
		End If

    Case "Durchgestellt"
        If OldStatus = "Rückruf" Or OldStatus = sNull Or OldStatus = "Durchgestellt" Then
    	  ' Check out what to do
        ' If status is being set back to New, reset all dates
        	If OldStatus <> sNull Then
            	iCallRec.SetValue "dateassigned", sNull
            	iCallRec.SetValue "dateresolved", sNull
        	End If

		Else
			isOK = False
		End If


    Case "AK zugewiesen"
        If OldStatus = "Fehlgeroutet" Or OldStatus = "Durchgestellt" Or OldStatus = "AK zugewiesen" Or OldStatus = "Angenommen"  Then
  		' If there is no workgroup, set the status back to "Durchgestellt"

        	If Not(iCallRec.HasLinkedRecord("callworkgroup")) Then
         	   iCallRec.SetValue STATUS, "Durchgestellt"
         	   iCallRec.SetValue "dateassigned", sNull
        	Else ' Set the date
         	   iCallRec.SetValue "dateassigned", "now"
        	End If
			If iApp.IntervalToSeconds(iCallRec.GetValue( "sd_time")) = 0 And  _
				 (iCallRec.GetValue( "mastercall_key") = "" Or iCallRec.GetValue( "mastercall_key") = "NULL") Then
	      	    dDateConnected = iCallRec.GetValueAsDate("datecallconnected")
		   		dDateAssigned= iCallRec.GetValueAsDate("dateassigned") 
				nSD_Time= iApp.DateToSeconds(dDateAssigned) - iApp.DateToSeconds(dDateConnected)
				iCallRec.SetValue "sd_time", iApp.SecondsToInterval( nSD_Time)
			End If
		Else
			isOK = False
		End If

    Case "Fehlgeroutet"
        If OldStatus = "AK zugewiesen" Or OldStatus = "Fehlgeroutet"  Then
    	  ' Check out what to do
		Else
			isOK = False
		End If

    Case "Angenommen"
        If OldStatus = "AK zugewiesen" Or OldStatus = "Angenommen" Or OldStatus = "Fehlgeroutet" Then
			' Problemmanager dürfen auch fehlgeroutete Meldungen annehmen
		   If OldStatus = "Fehlgeroutet" And ( InStr(iApp.GetUserGroups,"CQ_PM") <> 0 ) Then	
	   			iCallRec.SetValue "dateowned", "now"
		   Else
			  If OldStatus = "Fehlgeroutet" Then
				isOK = False
			  End If
	   		  iCallRec.SetValue "dateowned", "now"
		   	End If	
		Else
			isOK = False
		End If
    Case "Verworfen"
        If OldStatus = "AK zugewiesen" Or OldStatus = "Angenommen" Or OldStatus = "Fehlgeroutet" Then
		' Check out what to do

		Else
			isOK = False
		End If

    Case "Fertig gemeldet"

        If OldStatus = "Angenommen" Or OldStatus = "Fertig gemeldet" Then
			If OldStatus = "Angenommen" Then
	        	iCallRec.SetValue "dateresolved", "now"
			End If
			If iCallRec.HasLinkedRecord("callworkgroup") Then
				Set iCallWorkgroupRec = iCallRec.GetLinkedRecord("callworkgroup")
				If 	iCallWorkgroupRec.GetValue("autodocumented")="Ja" Then
					iCallRec.SetValue "callstatus", "Dokumentiert"
				    If CheckCallDocumented( iApp, iNetwork, iCallRec, sErrorMsg) Then
	        			iCallRec.SetValue "datedocumented", "now"
						iCallRec.SetValue "callstatus", "Dokumentiert"
						bAutoDocumented = True
					Else
						iCallRec.SetValue "callstatus","Fertig gemeldet"
					End If
				End If
			End If
		Else
			isOK = False
		End If

    Case "Dokumentiert"
        If OldStatus = "Fertig gemeldet" Or OldStatus = "Fertig akzeptiert" Or OldStatus = "Dokumentiert"  Then
	        	iCallRec.SetValue "datedocumented", "now"
		Else
			isOK = False
		End If
    Case "Geschlossen"
        If OldStatus = "Dokumentiert" Then
	        iCallRec.SetValue "dateclosed", "now"
		Else
			isOK = False
		End If
    End Select
	If Not isOK Then
		iApp.UserMsg "Der Statusübergang von '" & Oldstatus & "' zu '" & NewStatus & "' ist nicht erlaubt.", ebCritical
	End If
	CheckCallStatusChange =	isOK

End Function
' --------------------------------------------------
Sub SetCallStatus(iNetwork As DBNetwork, iCallRec As DBRecord)
' Set the status if foreign fields require.
Dim sStatus As String
Dim bBadrouting As Boolean
    sStatus = iCallRec.GetValue(STATUS)


	bBadrouting = False

    If iCallRec.HasLinkedRecord("callworkgroup") Then
        If sStatus = "Fehlgeroutet" And iCallRec.HasChanged("workgroupcall") Then
			If iCallRec.HasChanged(STATUS)  And iCallRec.Mode <> MODE_NEW Then
				If iCallRec.GEtOldValue(STATUS) = "Fehlgeroutet" Then bBadrouting = True
  			End If
			If ( Not iCallRec.HasChanged(STATUS) ) Or bBadrouting Then
            	iCallRec.SetValue STATUS, "AK zugewiesen"
            	iCallRec.SetValue "dateassigned", "now"
			End If
        End If

        If sStatus = "Neu" Or sStatus = "Durchgestellt" Then
            iCallRec.SetValue STATUS, "AK zugewiesen"
            iCallRec.SetValue "dateassigned", "now"
        End If
    Else
        If sStatus = "AK zugewiesen" Then
            iCallRec.SetValue STATUS, "Fehlgeroutet"
        End If
    End If
End Sub
'----------------------------------------------------------------

Function SetFlag(nTarget As Long, nFlag As Integer) As Long
' Sets the nFlag'th bit of the target integer
' Note that nFlag is actually off-by-one.  When nFlag = 0, set the 1 bit
    SetFlag = nTarget Or 2 ^ (nFlag)
End Function

'----------------------------------------------------------------

'----------------------------------------------------------------
Sub SetEscalationState(iNetwork As DBNetwork, iCallRec As DBRecord)
' The escalation state is an integer that records the current state of
' the DB record.  This state is used by the event server to determine 
' whether an escalation should be fired.
' The state is represented by setting bits of the integer that correspond
' to record states.  Here, we check those record states and set bits 
' appropriately.  Note that in the case of a closed call, we want to set
' all flags, preventing unnecessary escalations.
Dim nState As Long
Dim bIsClosed As Boolean
Dim nEscType As Integer
Dim iEscTbl As DBTable
Dim sCallPriority As String
Dim nCallType As Integer

Const nWalkBitMask =  2147483632 ' 0x7FFFFFF0
Const nMultiplMask =  1073741808 ' 0x3FFFFFF0 - to avoid overflow
Const nNewWalkBit  =  2147483616 ' 0x7FFFFFE0 - the lowest available bit

    Set iEscTbl = iNetwork.GetTable("callescalation")

	' Escalation will have the version coded in the bits 31 - 5
	' as a "0" between a large ammount of "1"
	' interesting is the bit position os a zero
	' Warning: there should be only one zero in the band
' Escalationsstati:
' nicht zugewiesen
' Fehlgeroutet
' nicht Angenommen
' nicht fertig gemeldet

' Callstati:
' Rückruf
' Durchgestellt
' AK zugewiesen
' Fehlgeroutet
' Verworfen
' Angenommen
' Fertig gemeldet
' Fertig akzeptiert
' Dokumentiert
' Geschlossen


	nState = 0
	If ( iCallRec.Mode = MODE_NEW ) Then
		nState = nNewWalkBit
	Else
		If Not( _
				iCallRec.HasChanged( "priority" ) _
				Or iCallRec.HasChanged( "categorycall" ) _
				Or iCallRec.HasChanged( "workgroupcall" ) _   
		) Then
			nState = CLng( iCallRec.GetValue( "escstatus" ) ) And nWalkBitMask
		End If
	End If
	If ( nState = 0 ) Then
		' compute the value because some escalation relevant
		' parameters have changed
		nState = CLng( iCallRec.GetValue( "escstatus" ) ) And nMultiplMask
		If ( nState = nMultiplMask ) Then
			' multiplication would cause overflow error
			nState = nNewWalkBit ' Recycling !!
		Else
			nState = Not( nState ) And nMultiplMask ' turn "0" to "1"
			nState = nState * 2 ' shift left
			nState = Not( nState ) And nWalkBitMask ' turn back
		End If
	End If
    bIsClosed = False

    ' For each state that is important to this record, set the flag
    ' if the condition no longer applies
'!!: "Closed" -> "geschlossen"
	' changed by Jacek Margos - "Warten" should escalate
	' only the rules for "Warten"

    If iCallRec.GetValue("callstatus") = "Geschlossen" _
	Or iCallRec.GetValue("callstatus") = "Fertig gemeldet" _
	Or iCallRec.GetValue("callstatus") = "Fertig akzeptiert" _
	Or iCallRec.GetValue("callstatus") = "Verworfen" _
	Or iCallRec.GetValue("callstatus") = "Dokumentiert" Then
        bIsClosed = True
        nEscType = iEscTbl.MapEnumStrToInt("type", "nicht fertig gemeldet")
'        nEscType = iEscTbl.MapEnumStrToInt("type", "Not Closed")
        nState = SetFlag(nState, nEscType)
    End If

    If iCallRec.HasLinkedRecord("callworkgroup")  Or bIsClosed Then
        nEscType = iEscTbl.MapEnumStrToInt("type", "nicht zugewiesen")
        nState = SetFlag(nState, nEscType)
    End If
    If iCallRec.GetValue("callstatus") = "Angenommen" Or bIsClosed Then
        nEscType = iEscTbl.MapEnumStrToInt("type", "nicht Angenommen")
        nState = SetFlag(nState, nEscType)
    End If


	If iCallRec.GetValue("callstatus") <> "Fehlgeroutet" Then
		nEscType = iEscTbl.MapEnumStrToInt("type", "Fehlgeroutet")
        nState = SetFlag(nState, nEscType)
	End If

    iCallRec.SetValue "escstatus", nState

End Sub

'----------------------------------------------------------------
'----------------------------------------------------------------------
Function CallUpdate() As Boolean
' Database record modifications.  No GUI required.
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iCallTable As DBTable
Dim iWebTable As DBTable
Dim iCallRec As DBRecord
Dim bRes As Boolean
Dim sErrorMsg As String

    On Error GoTo callupdate_error_handler
    '-------------------------------------------------
    Set iApp = GetApp
    Set iNetwork = iApp.ContextNetwork
    Set iCallTable = iApp.ContextTable
    Set iCallRec = iApp.ContextRecord
	bAutoDocumented = False
    If iCallRec.HasChanged(STATUS) Then
		If iCallRec.Mode = MODE_NEW Then

        	OldStatus = iCallRec.GetValue(STATUS)
        	NewStatus = iCallRec.GetValue(STATUS)
		Else
        	OldStatus = iCallRec.GetOldValue(STATUS)
        	NewStatus = iCallRec.GetValue(STATUS)
		End If
	Else 
        	OldStatus = iCallRec.GetValue(STATUS)
        	NewStatus = iCallRec.GetValue(STATUS)		
    End If
		If iCallRec.Mode = MODE_NEW Then
			 iCallRec.SetValue "coordinationtime", "00:00:00"
			 iCallRec.SetValue "totaltasktimespent", "00:00:00"
			 iCallRec.SetValue "totaltaskdoc", "00:00:00"
		End If
	' Now let's check for our links...
	' Try to get the table for WebQ Authorization.  This is done here because there
	' is a different alias depending on the application used.  If we find it, then 
	' we will know we are being processed for WebQ, and have some special circumstances
	' to contend with...

	If iNetwork.HasTable("webqauth") Then
		Set iWebTable = iNetwork.GetTable("webqauth")
	ElseIf iNetwork.HasTable("webqauthint") Then
		Set iWebTable = iNetwork.GetTable("webqauthint")
	End If

	If Not( iWebTable Is Nothing ) Then
		If iWebTable.RecordCount > 0 Then
			bWebQ = True
		   	Set iWebRec = iWebTable.GetRecord(0)

		Else
			bWebQ = False
		End If
	End If
		Set iWebTable = Nothing

	


	' Make sure that the links that are application specific are set.
	If (CheckCallLinks(iApp, iNetwork, iCallRec)  ) Then
        If ( _
                ( iCallRec.Mode = MODE_NEW ) _
                      And _
                ( iCAllRec.GetValue( "datereported" ) = "" ) _
        ) Then
            ' if not supplied from the GUI because using WebQ or BatchQ
            iCallRec.SetValue "datereported", "now"
        End If
        iCallRec.SetValue "datemodified", "now"
        iCallRec.SetValue "modifiedby", iApp.DBUser
		bRes = True
		If Not bFirstLevelCloseCall Then
        	SetCallStatus iNetwork, iCallRec

        	bRes =CheckCallStatusChange( iApp, iNetwork, iCallTable, iCallRec)

			If Not CheckValueChange(iApp, iCallRec)	Then
	  	  		CallUpdate = False
   				GoTo Exit_Function
			End If
			If Not CheckCallDocumented( iApp, iNetwork, iCallRec, sErrorMsg) Then
				iApp.UserMsg sErrorMsg , ebInformation
		   		bRes = False
			End If
		End If
        SetEscalationState iNetwork, iCallRec
		FindSLKSL iApp, iNetwork, iCallRec
		If bSendFAX Then
 			bSendFAX=False
		Else
        	bRes = bRes And iCallRec.WriteHistory("history")
		End If
		CallUpdate = bRes
	Else
		CallUpdate = False
		GoTo Exit_Function
	End If
	bAcceptCall= False
	If bRes Then   GoTo Clean_Function

Exit_Function:
   iCallRec.SetValue STATUS, OldStatus
 GoTo Clean_Function

Exit Function 
callupdate_error_handler:
CallUpdate = False
    iApp.UserMsg "CallUpdate error " & CStr(Err)
Clean_Function:
    Set iCallRec = Nothing
    Set iCallTable = Nothing
    Set iNetwork = Nothing
    Set iApp = Nothing
 
End Function






















































































































































































































































































































']]
'NAME = "CallPostUpdate"
'TYPE = 0
'TEMPLATE = "Sub CallPostUpdate()"
'TEXT = [[
'*****************************************************************************
'Script:       CallPostUpdate
'Purpose:      Business rules that are executed after a call is updated.
'Copyright:    Quartess 2002
'
'*****************************************************************************
'Option Explicit
Declare Function SaveMessage( iNetwork As DBNetwork,  sTo As String, sSubject As String, sMsg As String, sStylesheet As String, sTable As String, sKey As String) As Boolean
Declare Function CheckEmailAddress( sStr As String) As Boolean

Declare Function ConvertFormular(iApp As Application, iNetwork As DBNetwork, sTemplateFile As String, bHTML As Boolean )  As String
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

Public 	bFirstLevelCloseCall As Boolean
Public bAutoDocumented As Boolean
Public bNotifyCustomer As Boolean
Public bWebQ As Boolean

Global Const sEmptyStr = ""	 
Dim iDoc_TemplateTable As DBTable

'----------------------------------------------------------------------------------------
Sub NotifyCustomer(iApp As Application, iNetwork As DBNetwork,  iCallRec As DBRecord)
Dim iRelRec As DBRecord
Dim sTo As String
Dim sMethod As String
Dim sAddr As String
Dim sSubject As String
Dim sMsg As String
Dim nPriority As Integer
Dim sPriority As String
Dim bStatus As Boolean
Dim sName As String
        
	If iCallRec.HasLinkedRecord("customerint") Then
            Set iRelRec = iCallRec.GetLinkedRecord("customerint")
			'sMethod = iRelRec.GetValue("communicatepref")	' nicht die Methode am Kunden sondern ander Meldung
			sMethod = "Email"  ' iCallRec.GetValue("callbackmethod")
	Else 
		Exit Sub
    End If



    Select Case sMethod
    Case "Signal"
'    Case "Alert"
    Case "Email"
        sAddr = iRelRec.GetValue("emailcorr")
    Case "FAX", "Fax"
    Case "Funkruf","SMS"
'    Case "Pager"
    End Select

	sSubject = "Die Meldung " & iCallRec.GetValue("pkey") & " wird voraussichtlich bis zum "  & iCallRec.GetValue("date_sl_overdue") & " fertig gestellt" 
	sMsg = sSubject	& ", weil " & Basic.Eoln$ & iCallRec.GetValue("sl_overdue")

     Select Case sMethod
        Case "Signal"
        	sAddr = iRelRec.GetValue("loginname")
			sPriority =  iRelRec.GetValue("priority")
   			nPriority = iCallRec.GetTable.MapEnumStrToInt( "priority",sPriority) +1
   			If nPriority > 3 Then nPriority = 3
            iApp.SendAlert sAddr, iApp.DBUser, sSubject, nPriority, _
                           "call", iCallRec.GetKeyValue,"Warnung"
        Case "Email","Telefon","keine","Keine"
       	    sAddr = iRelRec.GetValue("emailcorr")
			bStatus = iApp.SendMail(sAddr, sSubject, "", sMsg,True)

        Case "FAX","Fax"
        	sAddr = iRelRec.GetValue("faxcorr")
        	sName = iRelRec.GetValue("fullname")
            bStatus = iApp.SendFax(sAddr, sSubject, sName, sMsg,True)

        Case "Funkruf","SMS"
        	sAddr = iRelRec.GetValue("pager")
            bStatus = iApp.SendPage(sAddr, sSubject,True)
	 End Select
End Sub 
'----------------------------------------------------------------------------------------


Sub CheckAutoClosed(iApp As Application, iNetwork As DBNetwork,  iCallRec As DBRecord)
Dim iCallmasterRec As DBRecord
Dim nOpenSubCalls As Integer
Dim nOpenTasks As Integer
Dim iSearchNetwork As DBNetwork
Dim iBrowser As DBBrowser
Dim iTaskTable As DBTable
Dim iCallMasterTable As DBTable
Dim iCallduplicateTable As DBTable
Dim sCallID As String

    If (iCallRec.HasLinkedRecord("callmaster")) And (iCallRec.GetValue("callstatus")="Fertig gemeldet" )Then
        Set iCallmasterRec = iCallRec.GetLinkedRecord("callmaster")
		If iCallmasterRec.GetValue("autoclosed") <> "Ja" Then	 Exit Sub
    Else
        Exit Sub
    End If
	If iCallmasterRec.GetValue("callstatus") <>"Angenommen" Then 		' Nur Angenommene Calls können Fertig gemeldet werden
        Exit Sub
	End If
	Set iCallMasterTable = iCallmasterRec.GetTable
' Now check possible autoclosed for this call
' Sind noch offene Aufträge da?
 		Set iSearchNetwork = iApp.CreateNetwork( "q_taskcount", "q_taskcount" )
   		Set iBrowser = iSearchNetwork.GetBrowser( "taskcountBrowser" )
   		Set iTaskTable = iSearchNetwork.GetTable( "task" )
		sCallID = iCallmasterRec.GetKeyValue
   		iTaskTable.QBEClear
   		iTaskTable.QBESetValue "calltask", sCallID

   		iTaskTable.QBESetValue "taskstatus", "In Arbeit"
		iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
		nOpenTasks = iBrowser.RecordCount
   		iTaskTable.QBEClear
        If  nOpenTasks <> 0 Then
            GoTo Exit_Sub
        End If
' Sub Calls checken
 		Set iBrowser = iSearchNetwork.GetBrowser( "callduplicateBrowser" )
   		Set iCallduplicateTable = iSearchNetwork.GetTable( "callduplicate" )
		iCallduplicateTable.Clear
		sCallID = iCallmasterRec.GetKeyValue
   		iCallduplicateTable.QBEClear
   		iCallduplicateTable.QBESetValue "mastercall_key", sCallID
   		iCallduplicateTable.QBESetValue "callstatus", "Rückruf|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen"
		iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
		nOpenSubCalls = iBrowser.RecordCount
		If nOpenSubCalls >0 Then
            GoTo Exit_Sub
        End If
	Set iTaskTable = Nothing
	Set iCallduplicateTable = Nothing
	Set iBrowser = Nothing
	Set iSearchNetwork = Nothing

' Mastercall fertig melden
	If iCallmasterRec.GetValue("callstatus") ="Angenommen" Then 
   		iCallmasterRec.SetValue "callstatus", "Fertig gemeldet"
		'Msgbox "Try Commit on " & iCallmasterRec.GetTable.Alias
		iCallMasterTable.Commit
	End If

Exit_Sub:
	Set iTaskTable = Nothing
	Set iCallduplicateTable = Nothing
	Set iBrowser = Nothing
	Set iSearchNetwork = Nothing

End Sub
'----------------------------------------------------------------------

' deleting ALL alerts for the specified call
Sub DeleteAlerts( iApp As Application, sCallKey As String )
Dim iTable As DBTable
Dim nRecs As Long
Dim i As Long
Dim iAlertRecord As DBRecord

	Set iTable = iApp.SysNetwork.GetTable("qw_alert")
	iTable.Clear
	iTable.QBEClear
	On Error Resume Next
	iTable.QBESetValue "tablename", "=call"
	iTable.QBESetValue "tablekey", "=" & sCallKey
	iTable.MaxRecords = -1
	iTable.Search
	nRecs = iTable.RecordCount
	For i = nRecs - 1 To 0 Step -1
		iTable.GetRecord( i ).Delete
	Next i
	iTable.Commit
	iTable.QBEClear
	iTable.Clear
	Set iTable = Nothing
End Sub
'----------------------------------------------------------------
Function NewRecord(iCallRec As DBRecord) As Boolean
' Determine whether this record is "new", even though we are post
' update.  To do this, look to see if the "datereported" field has
' an empty old value.
Dim sValue As String

    If iCallRec.HasOldValue("datemodified") Then
        sValue = iCallRec.GetOldValue("datemodified")
        If sValue = sEmptyStr Then
            NewRecord = True
        Else
            NewRecord = False
        End If
    End If

End Function
'----------------------------------------------------------------
' if the workgroup changes, then write the actual date and
' time to the old record and create a new record with
' the new workgroup and the actual time

Sub WriteCallDuration( iApp As Application, _
    iNetwork As DBNetwork, iCallRec As DBRecord )

Const FKey_WkGp = "workgroupcall"
Const STATUS = "callstatus"
Const CLOSED = "Geschlossen"

Dim bNewCall As Boolean
Dim bGrpChange As Boolean
Dim bOldClosed As Boolean
Dim bNewClosed As Boolean
Dim bClosing As Boolean
Dim bOpening As Boolean
Dim sCallID As String
Dim sNewGrpKey As String
Dim sOldGrpKey As String
Dim sDurNewGrp As String
Dim sDurOldGrp As String
Dim sNow As String
Dim iDurationTbl As DBTable
Dim nRecs As Long
Dim i As Long
Dim iDurationRec As DBRecord
'Dim sNewGroupRec As DBRecord

	On Error GoTo writecallduration_error_handler

	sNow = CStr( Now() )
	sCallID = iCallRec.GetValue( "pkey" )
	sNewGrpKey = iCallRec.GetValue( FKey_WkGp )
	sOldGrpKey = sNewGrpKey ' !!
	sDurNewGrp = ""
	sDurOldGrp = ""
	bNewCall = NewRecord( iCallRec )
	bNewClosed = ( InStr( CLOSED, iCallRec.GetValue( STATUS ) ) > 0 )
	bOldClosed = bNewClosed

	If Not( bNewCall ) Then
		bGrpChange = iCallRec.HasChanged( FKey_WkGp )
		If bGrpChange Then
			If iCallRec.HasOldValue( FKey_WkGp ) Then
				sOldGrpKey = iCallRec.GetOldValue( FKey_WkGp )
			End If
			If ( sOldGrpKey = "" ) _
			Or ( sOldGrpKey = "-1" ) _
			Or ( sOldGrpKey = sNewGrpKey ) Then
				sOldGrpKey = sNewGrpKey ' !!
				bNewCall = True
				bGrpChange = False
			Else
				sDurNewGrp = sNewGrpKey
				sDurOldGrp = sOldGrpKey
			End If
		End If
	End If
	If Not( bNewCall ) Then
		If iCallRec.HasChanged( STATUS ) Then
			bOldClosed = ( InStr( CLOSED, iCallRec.GetOldValue( STATUS ) ) > 0 )
		Else
			bOldClosed = bNewClosed
		End If
		bClosing = ( bNewClosed And Not( bOldClosed ) )
		bOpening = ( Not( bNewClosed ) And bOldClosed )
		If Not( bGrpChange Or bClosing Or bOpening ) Then
			Exit Sub
		End If
	Else
		bClosing = False
		bOpening = False
	End If

	If bOpening Then		' just like a new call (the old status
		bGrpChange = False	' is "closed": like "non-existent")
		sDurNewGrp = ""	' no new workgroup
		sDurOldGrp = ""	' no old workgroup
	End If
	If bGrpChange And bNewClosed And bOldClosed Then
		'sDurNewGrp = "-1"	' forwarded in the closed status
		'sDurOldGrp = "-1"	' a record without new and old group
		Exit Sub			' do nothing: "closed" is like "non-existent"
	End If

	' because backiffling in the GUI causes problems
	' GUI sets additional search constraints
	Set iDurationTbl = iNetwork.GetTable( "q_callduration" )
	iDurationTbl.Clear
	iDurationTbl.QBEClear


	If ( bGrpChange Or bClosing ) Then
		iDurationTbl.QBESetValue "callcallduration", sCallID
		iDurationTbl.QBESetValue "groupcallduration", sOldGrpKey
		iDurationTbl.QBESetValue "date_until", "NULL" ' !! only these
		iDurationTbl.Search
		nRecs = iDurationTbl.RecordCount
		If nRecs > 0 Then
			For i = 0 To nRecs - 1
				Set iDurationRec = iDurationTbl.GetRecord( i )
				iDurationRec.SetValue "date_until", sNow
				iDurationRec.SetValue "newgroup", sDurNewGrp
				iDurationRec.SetValue "isclosed", IIF( bClosing, 1, 0 )
				Set iDurationRec = Nothing
			Next i
		End If
	End If

	If ( bNewCall Or bGrpChange Or bOpening ) Then
		Set iDurationRec = iDurationTbl.AddRecord
		iDurationRec.SetValue "callcallduration", sCallID
		iDurationRec.SetValue "groupcallduration", sNewGrpKey
		iDurationRec.SetValue "oldgroup", sDurOldGrp
		iDurationRec.SetValue "date_from", sNow
		If bNewClosed Then
			iDurationRec.SetValue "date_until", sNow
			iDurationRec.SetValue "isclosed", 1			
		End If
	End If

	iDurationTbl.Commit
	iDurationTbl.Clear
	iDurationTbl.QBEClear

writecallduration_error_handler:
	' there is nothing we can do !!
	Set iDurationRec = Nothing
	Set iDurationTbl = Nothing
End Sub

'----------------------------------------------------------------
Sub WriteEventRecord(iApp As Application, _
    iNetwork As DBNetwork, iCallRec As DBRecord)
Dim iEventTbl As DBTable
Dim iEventRec As DBRecord
Dim iTable As DBTable
Dim sStr As String
Dim lInterval As Long
Dim sRelTable As String, sRelFieldName As String

    Set iEventTbl = iNetwork.GetTable("callevent")
    Set iEventRec = iEventTbl.AddRecord()
    iEventRec.SetValue "callcallevent", iCallRec.GetKeyValue
    iEventRec.SetValue "eventdate", "now"
    iEventRec.SetValue "creator", iApp.DBUser

    If iCallRec.HasChanged("priority") Then
        iEventRec.SetValue "priority", iCallRec.GetValue("priority")
    End If

    If iCallRec.HasChanged("callstatus") Then
        iEventRec.SetValue "callstatus", iCallRec.GetValue("callstatus")
    End If

    ' Decide which customer table to use
    If iNetwork.HasTable("customerint") Then
        sRelTable = "customerint"
    End If

    If iCallRec.HasChanged("employeecall") Then
        Set iTable = iNetwork.GetTable(sRelTable)
        sStr = iCallRec.GetValue("employeecall")
        If Len(sStr) > 0 Then
            If CLng(sStr) > 0 Then
                sStr = iTable.GetValueWhere("fullname", "pkey", sStr)
            Else
                sStr = sEmptyStr
            End If
        Else
            sStr = sEmptyStr
        End If
        iEventRec.SetValue "customer", sStr
    End If

    If iCallRec.HasChanged("workgroupcall") Then
        Set iTable = iNetwork.GetTable("callworkgroup")
        sStr = iCallRec.GetValue("workgroupcall")
        If Len(sStr) > 0 Then
            If CLng(sStr) > 0 Then
                sStr = iTable.GetValueWhere("name", "pkey", sStr)
            Else
                sStr = sEmptyStr
            End If
        Else
            sStr = sEmptyStr
        End If
        iEventRec.SetValue "workgroup", sStr
    End If

    If iCallRec.HasChanged("categorycall") Then
        Set iTable = iNetwork.GetTable("category")
        sStr = iCallRec.GetValue("categorycall")
        If Len(sStr) > 0 Then
            If CLng(sStr) > 0 Then
                sStr = iTable.GetValueWhere("name", "pkey", sStr)
            Else
                sStr = sEmptyStr
            End If
        Else
            sStr = sEmptyStr
        End If
        iEventRec.SetValue "category", sStr
    End If

    If iCallRec.HasChanged("process_key") Then
        Set iTable = iNetwork.GetTable("process")
        sStr = iCallRec.GetValue("process_key")
        If Len(sStr) > 0 Then
            If CLng(sStr) > 0 Then
                sStr = iTable.GetValueWhere("processname", "pkey", sStr)
            Else
                sStr = sEmptyStr
            End If
        Else
            sStr = sEmptyStr
        End If
        iEventRec.SetValue "processname", sStr
    End If

    iEventTbl.Commit
	Set iEventTbl = Nothing
End Sub

'----------------------------------------------------------------
Sub ScheduleEscalations(iApp As Application, _
    iNetwork As DBNetwork, iCallTable As DBTable, _
    iCallRec As DBRecord)
Dim iEscTbl As DBTable
Dim iEscRec As DBRecord
Dim iTable As DBTable
Dim iRecord As DBRecord
Dim nTblKey As Long
Dim sEscWrkgrpKey As String
Dim sWrkgrpKey As String
Dim nWrkgrpKey As Long
' changed by Jacek Margos
Dim sCategoryKey As String
Dim sPriority As String
Dim nPriority As Integer
Dim nRecs As Long
Dim i As Integer
Dim nDelay As Long
Dim nRepeatMins As Long
Dim dWhen As Date
Dim sStr As String
Dim sUnits As String
Dim sType As String
Dim sSubject As String
Dim nStatus As Long

' for the Escalation by Jacek Margos
Dim dNow As Date
Dim dReported As Date
Dim nWalkBit As Long
Dim sOldEscStatus As String
Dim sNewEscStatus As String
Const nWalkBitMask =  2147483632 ' 0x7FFFFFF0


''   Escalations are scheduled for new calls or if the call priority has
''   changed or if the workgroup has changed.
	' Escalation should be written for new calls
	' and if some escalation relevant parameter
	' of the call has changed
	If 	iCallRec.HasOldValue( "escstatus" )	Then
		sOldEscStatus = iCallRec.GetOldValue( "escstatus" )
	Else
		sOldEscStatus =""
	End If
	sNewEscStatus = iCallRec.GetValue( "escstatus" )
	If Not( NewRecord( iCallRec ) ) Then
		If Not( iCallRec.HasChanged( "escstatus" ) ) Then
			' we are sure the version of
			' the escalation has not changed
			Exit Sub
		End If
		' even if the "escstatus" has changed it does not
		' mean we have to write new escalations - the field's
		' value changes on group assignment and closing, too
		If ( ( sOldEscStatus <> "" ) And ( sNewEscStatus <> "" ) ) Then
			If ( _
				( CLng( sOldEscStatus ) And nWalkBitMask ) _
					= _
				( CLng( sNewEscStatus ) And nWalkBitMask ) _
			) Then
				' I knew it - it has not changed !
				Exit Sub
			End If
		End If
	'Else
		' we have to schedule all escalations for new records
	End If
	dNow = Now()
	sStr = iCallRec.GetValue( "datereported" )
	If sStr <> "" Then
		dReported = CDate( sStr )
	Else
		dReported = dNow ' it should never happen
	End If

	nWalkBit = CLng( sNewEscStatus )
	nWalkBit = ( Not( nWalkBit ) ) And nWalkBitMask ' turn "0" to "1"

	' end of modifications


    ' Find all escalation records that match the current call's 
    ' priority.  Note that this could be modified to use other
    ' selection criteria, depending on the structure of the 
    ' escalation table.
    sPriority = iCallRec.GetValue("priority")
    nPriority = iCallTable.MapEnumStrToInt("priority", sPriority)

    Set iEscTbl = iNetwork.GetTable("callescalation")
    iEscTbl.Clear
    ' Select on call priority
    iEscTbl.QBESetValue "priority", "|" & sPriority
'!!: "call" -> "Meldung"
    iEscTbl.QBESetValue "targettable", "Meldung"
'    iEscTbl.QBESetValue "targettable", "call"
    ' Select on call business impact

    ' Select on organization alert (HOT)

    sWrkgrpKey = iCallRec.GetValue("workgroupcall")
	sCategoryKey = iCallRec.GetValue( "categorycall" )
	If (sWrkgrpKey = "") Or (sWrkgrpKey = "NULL") Then
		iEscTbl.QBESetValue "groupescalation", "NULL"
	Else
		iEscTbl.QBESetValue "groupescalation", "NULL|" & sWrkgrpKey
	End If
	If (sCategoryKey = "") Or (sCategoryKey = "NULL")  Then
		iEscTbl.QBESetValue "categoryescalation", "NULL"
	Else
		iEscTbl.QBESetValue "categoryescalation", "NULL|" & sCategoryKey
	End If
    iEscTbl.Search
    nRecs = iEscTbl.RecordCount

    ' For each escalation record, calculate the firing time,
    ' using the business calendar.  Then schedule.
    If nRecs > 0 Then
        Set iTable = iApp.SysNetwork.GetTable("qw_events")
        iTable.Clear
        For i=0 To nRecs - 1
            Set iEscRec = iEscTbl.GetRecord(i)
            nDelay = Val(iEscRec.GetValue("delay"))
            sUnits = iEscRec.GetValue("delayunits")
            Select Case sUnits
'!!: "Hours" -> "Stunden"
       	        Case "Stunden"
                    nRepeatMins = nDelay*60
'!!: "Minutes" -> "Minuten"
       	        Case "Minuten"
'       	        Case "Minutes"
'                    dWhen = iApp.AddBusinessTime(Now, 0, nDelay)
                    nRepeatMins = nDelay
            End Select
'           The reference is always datereported - the startpoint
'           for the escalation process
			'dWhen = CDate( iCallRec.GetValue( "datereported" ) )
			' modification by Jacek Margos
			' we need to decide if the base time is "datereported" or now()
			If ( iEscRec.GetValue("basetime") = "Gemeldet" ) Then
				dWhen = dReported
			Else
				dWhen = dNow
			End If
			' the customer wants to use the business time (work schedule)
			'dWhen = DateAdd( "n", nRepeatMins, dWhen )
			' the customer does not want to use BusinessTime anymore
			dWhen = DateAdd( "n", nRepeatMins, dWhen )
			'dWhen = iApp.AddBusinessTime( dWhen, 0, nRepeatMins )
			' end modification by Jacek Margos

'           If the event should have happen in the past
'           it's probably happened
'           If dWhen < Now() Then
'           End If
'       End Changes
            sSubject = ConvertFormular(iApp, iNetwork, CStr(iEscRec.GetValue("subject")),true)
			If Len(sSubject) > 240 Then				' qw_events table limitation
			   sSubject = Left$(sSubject,240)
	  		End If

            If iEscRec.GetValue("repeated") = "0" Then
                nRepeatMins = 0
            End If

'           Type of the escalation
            sType = iEscRec.GetValue("type")
            nStatus = iEscTbl.MapEnumStrToInt("type", sType)
            nStatus = 2 ^ (nStatus)  ' Set the bit position
'			Type of the call ( see CallUpdate() - SetEscalationState
'			we set the escalation state so we need to change it here also
			'sType = iCallRec.GetValue( "priority" )
			'nStatus = nStatus Or 2 ^ ( 8 + iEscTbl.MapEnumStrToInt( "priority", sType ) )
			nStatus = nStatus Or nWalkBit


'           Try the workgroup of the call - if no workgroup
'           send to the escalation workgroup
            sStr = iEscRec.GetValue("notifytarget")

'           Which is the workgroup of the call ?
			' modified by Jacek Margos - do not destroy the value of "sWrkgrpKey"
			'sWrkgrpKey = iCallRec.GetValue("workgroupcall")
			If sStr = "Eskalationsgruppe" Or sWrkgrpKey = "-1" _
			 Or sWrkgrpKey = "" Or sWrkgrpKey = "NULL" Then
				' changed by Jacek Margos
				'sWrkGrpKey = iEscRec.GetValue("groupescalation")
				sStr = iEscRec.GetValue("escgroupescalation")
			Else
				sStr = sWrkgrpKey
			End If

			' modification by Jacek Margos - chedule all escalations
			' schedule Escalations which should have been written in
			' the past only if the option is set
			If ( dWhen >= dNow ) Or ( iEscRec.GetValue( "past" ) = "1" ) Then
			'' if only the workgroup has changed
			'' and the escalation rule is for the 'Escalation Group'
			'' do not re-schedule: the old escalation is (has been) OK
			'If Not( bGroupOnly And ( sStr = "Eskalationsgruppe" ) _
			'		And ( iEscRec.GetValue("groupescalation") = "-1" ) ) Then
	            Set iRecord = iTable.AddRecord
	            iRecord.SetValue "when", CStr(dWhen)
	            iRecord.SetValue "workgroupkey", sStr ' modification Jacek Margos
	            iRecord.SetValue "escalationkey", iEscRec.GetKeyValue
	            iRecord.SetValue "tablename", "call"
	            iRecord.SetValue "tablekey", iCallRec.GetKeyValue
	            iRecord.SetValue "severity", nPriority
	            iRecord.SetValue "message", sSubject
	            iRecord.SetValue "escstatus", nStatus
	            iRecord.SetValue "tier", iEscRec.GetValue("tier")
	            iRecord.SetValue "agent", CStr(iApp.EscalationAgent)
	            iRecord.SetValue "sender", "stephan.thuemmler@daimlerchrysler.com" 'iApp.Name
	            iRecord.SetValue "datemodified", Now
	            iRecord.SetValue "repeatinterval", nRepeatMins
			End If
			''End Changes
			' end of modification

		Next i
        iTable.Commit
        iTable.Clear
    End If
    ' Clear the QBE data in escalation
    iEscTbl.QBEClear
	Set iEscTbl = Nothing	
	Set iTable = Nothing
End Sub
'----------------------------------------------------------------
Function ActionMsg(iApp As Application, iNetwork As DBNetwork, iCallRec As DBRecord, _
    iActionRec As DBRecord, sSubject As String, sStylesheet As String) As String
' Collect important information for a call and format it into an
' message.

Dim sMsg As String
Dim iXMLTable As DBTable
Dim sDoc_key As String
Dim sXML_key As String
 On Error GoTo Error_handler
    sDoc_key= iActionRec.GetValue("doc_template_key") 
    If sDoc_key <> "" And sDoc_key <> "NULL" Then
		 iDoc_TemplateTable.QBEClear
		 iDoc_TemplateTable.Clear
		 iDoc_TemplateTable.QBESetValue	"pkey",sDoc_key
		 iDoc_TemplateTable.Search
		 sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("xsl_stylesheet")
    	sXML_key= iDoc_TemplateTable.GetRecord(0).GetValue("xml_template_key") 
    	If sXML_key <> "" And sXML_key <> "NULL" Then
			Set iXMLTable = iNetwork.GetTable("xml_template")
		 	sMsg = iXMLTable.GetValueWhere("xmltext","pkey",sXML_key)
			sMsg = ConvertFormular(iApp,iNetwork,  sMsg,true)
		Else
	   		sMsg ="<doc>Fehler! Kein Text!</doc>"
			sStylesheet= "default.xsl"
		End If
	Else
		sMsg ="<doc>Fehler! Kein Text!</doc>"
		sStylesheet= "default.xsl"
	End If
    ActionMsg = sMsg
	Set iXMLTable = Nothing
	Exit Function
	Error_handler:
		sMsg ="<doc>Error:" & CStr(Err) & ": " & Error$ & "</doc>"
		sStylesheet= "default.xsl"
	    ActionMsg = sMsg
   		Set iXMLTable = Nothing

End Function

'----------------------------------------------------------------
Function ActionAddr(iRecord As DBRecord, _
     iActionRec As DBRecord, sName As String) As String
' Build the action's address list 
Dim iRelRec As DBRecord
Dim sTo As String
Dim sMethod As String
Dim sAddr As String

    sTo = iActionRec.GetValue("recipient")
    sMethod = iActionRec.GetValue("method")
	sAddr=""
    Select Case sTo
    Case "Kunde"
'    Case "Customer"
        If iRecord.HasLinkedRecord("customerint") Then
            Set iRelRec = iRecord.GetLinkedRecord("customerint")
	    GoTo EmployeeAddress
        End If
    Case "Mitarbeiter"
'    Case "Agent"
        If iRecord.HasLinkedRecord("agent") Then
            Set iRelRec = iRecord.GetLinkedRecord("agent")
	    GoTo EmployeeAddress
        End If
    Case "Arbeitsgruppe"
'    Case "Workgroup"
        If iRecord.HasLinkedRecord("callworkgroup") Then
            Set iRelRec = iRecord.GetLinkedRecord("callworkgroup")
            sAddr = iRelRec.GetValue("notificationaddr")
        End If
'!!: "CC List" -> "CC Liste"
    Case "CC Liste"
'    Case "CC List"
            sAddr = iRecord.GetValue("cclist")
    End Select

    ActionAddr = sAddr
    Exit Function



EmployeeAddress:
    Select Case sMethod
'!!: "Alert" -> "Signal"
    Case "Signal"
'    Case "Alert"
        sAddr = iRelRec.GetValue("loginname")
    Case "Email"
        sAddr = iRelRec.GetValue("emailcorr")
    Case "FAX", "Fax"
        sAddr = iRelRec.GetValue("faxcorr")
        sName = iRelRec.GetValue("fullname")
    Case "Funkruf","SMS"
'    Case "Pager"
        sAddr = iRelRec.GetValue("pager")
    End Select

    ActionAddr = sAddr
End Function
'----------------------------------------------------------------

Sub NotifyWorkgroup( iApp As Application, iAlertNetwork As DBNetwork ,iNetwork As DBNetwork, iWorkgroupRecord As DBRecord,  sSubject As String,  sMsg As String, sTable As String, sTableKey  As String)
Dim iGroupmemberTbl As DBTable
Dim iEmployeeTbl As DBTable
Dim iMemberRec As DBRecord
Dim i As Integer
Dim sAddr As String
Dim nPriority As Integer
Dim sPriority As String
Dim sStylesheet As String
Dim bStatus As Boolean
Dim sCurrenUserKey As String
Dim sMethod As String

 ' Achtung sStylesheet wird überschrieben!
	On Error GoTo NotifyWorkgroup_errorhandler
	sCurrenUserKey = iApp.CurrentUserKey
	Set	 iGroupmemberTbl =	iAlertNetwork.GetTable("groupmember")
	If iWorkgroupRecord.GetValue("notifyowngroup") = "Nein" And sCurrenUserKey <> "" Then
		iGroupmemberTbl.Clear
		iGroupmemberTbl.QBEClear
		iGroupmemberTbl.QBESetValue "workgroupgroup", "=" & iWorkgroupRecord.GetValue("pkey")
		iGroupmemberTbl.QBESetValue "employeegroup","=" & sCurrenUserKey
   		iGroupmemberTbl.Search
		If iGroupmemberTbl.RecordCount > 0 Then GoTo Exit_Sub 
	End If
	Set	 iEmployeeTbl =	iAlertNetwork.GetTable("employee")
	iGroupmemberTbl.Clear
	iGroupmemberTbl.QBEClear
	iGroupmemberTbl.QBESetValue "workgroupgroup", "=" & iWorkgroupRecord.GetValue("pkey")
	iGroupmemberTbl.QBESetValue "notifymethod","!Keine"
	iGroupmemberTbl.Search
	For i=1 To iGroupmemberTbl.RecordCount
	   Set iMemberRec = iGroupmemberTbl.GetRecord(i-1)
	   sMethod = iMemberRec.GetValue("notifymethod")
	   If sCurrenUserKey = iMemberRec.GetValue("employeegroup") Then sMethod = "Keine"  ' keine Eigenbenachrichtigung!
	   Select Case 	sMethod
	
        Case "Signal"
			sPriority = iApp.ContextRecord.GetValue("priority")
   			nPriority = iApp.ContextTable.MapEnumStrToInt( "priority",sPriority) +1
   			If nPriority > 3 Then nPriority = 3
			sAddr = iEmployeeTbl.GetValueWhere("loginname","pkey", iMemberRec.GetValue("employeegroup"))
            iApp.SendAlert sAddr, iApp.DBUser, sSubject, nPriority, _
                           sTable , sTableKey,"Warnung"
        Case "Email"
			sStylesheet =iMemberRec.GetValue("xsl_stylesheet")
			If sStylesheet = "" Then
				 sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("email_xsl")
			End If
			sAddr = iEmployeeTbl.GetValueWhere("emailcorr","pkey", iMemberRec.GetValue("employeegroup"))
			If sAddr <> "" Then		
				bStatus = SaveMessage( iNetwork,  "email://" & sAddr, sSubject, sMsg, sStylesheet, sTable , sTableKey )
			Else
				iApp.UserMsg "Email-Benachrichtigung für Mitarbeiter ID. " & iMemberRec.GetValue("employeegroup") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If

        Case "FAX","Fax"
			sStylesheet =iMemberRec.GetValue("xsl_stylesheet")
			If sStylesheet = "" Then
				 sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("fax_xsl")
			End If
			sAddr = iEmployeeTbl.GetValueWhere("faxcorr","pkey", iMemberRec.GetValue("employeegroup"))	
			If sAddr <> "" Then				
				bStatus = SaveMessage( iNetwork, "rightfax://" &  sAddr, sSubject, sMsg, sStylesheet,sTable , sTableKey)
			Else
				iApp.UserMsg "FAX-Benachrichtigung für Mitarbeiter ID. " & iMemberRec.GetValue("employeegroup") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If

        Case "Funkruf","SMS"
			sStylesheet =iMemberRec.GetValue("xsl_stylesheet")
			If sStylesheet = "" Then
				 sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("sms_xsl")
			End If
			sAddr = iEmployeeTbl.GetValueWhere("pager","pkey", iMemberRec.GetValue("employeegroup"))
			If sAddr <> "" Then							
	  			bStatus = SaveMessage( iNetwork,  "sms://" & sAddr, sSubject, sMsg, sStylesheet, sTable , sTableKey )
			Else
				iApp.UserMsg "SMS-Benachrichtigung für Mitarbeiter ID. " & iMemberRec.GetValue("employeegroup") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If

	   End Select		
	Next i 	
	Set iGroupmemberTbl = Nothing 
	Set iMemberRec = Nothing 
	Exit Sub
NotifyWorkgroup_errorhandler:
    iApp.UserMsg "CallPostUpdate-NotifyWorkgroup error " & CStr(Err) & ": " & Error$  
Exit_Sub:
	Set iGroupmemberTbl = Nothing 
	Set iMemberRec = Nothing 
End Sub 
'----------------------------------------------------------------
Function CheckAddress(iApp As Application,iNetwork As DBNetwork, iTaskRec As DBRecord, sMethod As String,sAddr As String) As Boolean
Dim iTable As DBTable
Dim sQuestion As String
Dim sGroupName As String
Dim bOK As Boolean 
	 If sMethod ="Bearbeiter" Or sMethod ="Keine"  Then
 		 CheckAddress = True
  		 Exit Function		
	 End If	

	 Set iTable = iNetwork.GetTAble("taskworkgroup")
	 sGroupName = iTable.GetValueWhere("name","pkey", "=" & iTaskRec.GetValue("workgrouptask"))
	 sQuestion =  "Ist die " & sMethod & "-Adresse von " & sGroupname & " richtig?"
	 If sMethod = "Email" Then
	   If sAddr = "" Then  sAddr ="@daimlerchrysler.com"
	    Do 
		  sAddr = Inputbox$(sQuestion,"System möchte " & sMethod & " an " & sGroupname & "versenden.",sAddr)
		  If sAddr = "" Then 
			   bOK	= True
			   CheckAddress = False
		  Else
				bOK = CheckEmailAddress(sAddr)
	 			CheckAddress = True
		  End If
	    Loop Until 	bOK
	 Else		
 		 sAddr = Inputbox$(sQuestion,"System möchte " & sMethod & " an " & sGroupname & "versenden.",sAddr)	
	 	If sAddr = "" Then 
		 	CheckAddress= False
	 	Else
	 		CheckAddress = True
  		End If
	End If
	Set iTable = Nothing	
End Function
'----------------------------------------------------------------
Sub RunActions(iApp As Application,iNetwork As DBNetwork, iCallTable As DBTable, iCallRec As DBRecord)
Dim iAlertNetwork As DBNetwork
Dim iActionTbl As DBTable
Dim iActionRec As DBRecord
Dim iCustomerRec As DBRecord
Dim iTable As DBTable
Dim iWorkgroupTable As DBTable
Dim iWorkgroupRecord As DBRecord
Dim nTblKey As Long
Dim nRecs As Long
Dim i As Integer
Dim sType As String
Dim sStatus As String
Dim sPriority As String
Dim sGrpKey As String
Dim sCategoryKey As String
Dim sAddr As String
Dim sName As String
Dim sSubject As String
Dim sMethod As String
Dim sMsg As String
Dim bStatus As Boolean
Dim nPriority As Integer
Dim bFeedback As Boolean
Dim sStylesheet As String
Dim sDefaultStylesheet As String
Dim sDummy As String


    ' Only do this if the status has changed or workgroup changed an the call has no parent call
    If Not( iCallRec.HasChanged("callstatus") Or iCallRec.HasChanged("workgroupcall") ) Or iCallrec.GetValue("mastercall_key") <> "" Then
        Exit Sub
    End If
	
    ' Find all action records that match the current call's 
    ' status.  Note that this could be modified to use other
    ' selection criteria, depending on the structure of the 
    ' action table.
    sStatus = iCallRec.GetValue("callstatus")
	sPriority = iCallRec.GetValue("priority")
	sCategoryKey = iCallRec.GetValue( "categorycall" )
    Set iActionTbl = iNetwork.GetTable("callaction")
    iActionTbl.Clear
    iActionTbl.QBEClear
	If bAutoDocumented Then
	    iActionTbl.QBESetValue "statusevent", sStatus & "|Fertig gemeldet"
		bAutoDocumented = False
	Else
	    iActionTbl.QBESetValue "statusevent", sStatus 
	End If

	If sPriority <>"" Then
    	iActionTbl.QBESetValue "priority", "NULL|" & sPriority
	Else
	   iActionTbl.QBESetValue "priority", "NULL"
	End If
    iActionTbl.QBESetValue "targettable", "Meldung"
	sGrpKey = iCallRec.GetValue( "workgroupcall" )
	If (sGrpKey = "") Or (sGrpKey = "NULL") Then
		' the call does not have a workgroup
		iActionTbl.QBESetValue "groupaction", "NULL"
	Else
		' the call does have a workgroup
		iActionTbl.QBESetValue "groupaction", "NULL|" & sGrpKey
		Set iWorkgroupRecord = iCallRec.GetLinkedRecord("callworkgroup")
		iActionTbl.QBESetValue "migration", iWorkgroupRecord.GetValue("migration")
	End If
	If (sCategoryKey = "") Or (sCategoryKey = "NULL") Then
		iActionTbl.QBESetValue "categoryaction", "NULL"
	Else
		iActionTbl.QBESetValue "categoryaction", "NULL|" & sCategoryKey
		iActionTbl.QBESetValue "excludecategory", "!" & sCategoryKey & "," & "|NULL"

	End If
    iActionTbl.Search

    nRecs = iActionTbl.RecordCount
    If nRecs =0 Then
        Exit Sub
    End If
	Set	 iAlertNetwork = iApp.CreateNetwork( "q_alert")

    ' For each action record, do the right thing
    For i=0 To nRecs - 1
        Set iActionRec = iActionTbl.GetRecord(i)
        sSubject = ConvertFormular(iApp, iNetwork,CStr(iActionRec.GetValue("subject")),true)
        sMethod = iActionRec.GetValue("method")
        sAddr = ActionAddr(iCallRec, iActionRec, sName)
		If Len(sSubject) > 240 Then				' qw_events table limitation
			   sSubject = Left$(sSubject,240)
		End If

        ' An action that notifies a workgroup is a special case, since
        ' the event server knows how to extract the workgroup's preferred 
        ' notification method, and explode the workgroup into owners.
        If iActionRec.GetValue("recipient") = "Arbeitsgruppe" Then
		   sMethod = iWorkgroupRecord.GetValue("notifymethod")
		   bFeedback =False
		   sAddr = 	iWorkgroupRecord.GetValue("notificationaddr")
        End If
		If iActionRec.GetValue("recipient") = "Kunde" And bFirstLevelCloseCall Then	   ' keine Meldung senden
		   			sMethod = "Keine" 
        End If
		
		If iActionRec.GetValue("recipient") = "folgende Adresse" Then
		   sAddr=iActionRec.GetValue("notificationaddr")
		End If
		If iActionRec.GetValue("recipient") = "NM Meisterei" And Not (iWorkgroupRecord Is Nothing) Then		
		   sMethod = iWorkgroupRecord.GetValue("notifymethod")
		   bFeedback =True
		   sAddr = 	iWorkgroupRecord.GetValue("notificationaddr")
		Else
		   bFeedback =False
		End If
	   If Not bWebQ Then
		' Dieser Abschnitt funktioniert nicht in WebQ
  		   If ( InStr(AppGetActive$,"QGateway") = 0 And iActionRec.GetValue("confirmation") ="Ja") And (sMethod <> "keine") And Not bFeedback Then
  				Dim sResponseText As String
  				Dim nAnswer As Integer
  				If sMethod = "Bearbeiter" Then
   					sResponseText = "System möchte den Bearbeiter benachrichtigen." & Basic.Eoln$
				Else
					sResponseText = "System möchte ein " & sMethod & " an " & sAddr &" senden." & Basic.Eoln$
	 			End If	
	 			nAnswer = iApp.UserResponseMsg(sResponseText & " Ist das in Ordnung?", ebYesNo, "Benachrichtignung Regel " & iActionRec.GetValue("name"))
	 			If nAnswer = ebNo Then sMethod = "Keine" 
    	   End If
	  	   If InStr(AppGetActive$,"QGateway") = 0 And bFeedback Then 
				If Not CheckAddress(iApp,iNetwork, iCallRec, sMethod ,sAddr ) Then sMethod = "keine"
	  	   End If
	  End If
	
     Select Case sMethod
        Case "Signal"
   			nPriority = iCallTable.MapEnumStrToInt( "priority",sPriority) +1
   			If nPriority > 3 Then nPriority = 3
            iApp.SendAlert sAddr, iApp.DBUser, sSubject, nPriority, _
                           "call", iCallRec.GetKeyValue,"Warnung"
        Case "Email"
            sMsg = ActionMsg(iApp,iNetwork, iCallRec, iActionRec, sSubject, sDefaultStylesheet)
			'bStatus = iApp.SendMail(sAddr, sSubject, "", sMsg,bFeedback)
			sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("email_xsl")
			If sStylesheet = "" Then sStylesheet = sDefaultStylesheet
			If sAddr <> "" Then
				bStatus = SaveMessage( iNetwork,  "email://" & sAddr, sSubject, sMsg, sStylesheet, "call", iCallRec.GetKeyValue )
			Else
				iApp.UserMsg "Email-Benachrichtigung für Aktionsregel Nr. " & iActionRec.GetValue("pkey") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If
        Case "FAX","Fax"
            sMsg = ActionMsg(iApp,iNetwork, iCallRec, iActionRec, sSubject, sDefaultStylesheet)
			sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("fax_xsl")
			If sStylesheet = "" Then sStylesheet = sDefaultStylesheet
            'bStatus = iApp.SendFax(sAddr, sSubject, sName, sMsg,bFeedback)
			If sAddr <> "" Then	
		   		bStatus = SaveMessage( iNetwork, "rightfax://" &  sAddr, sSubject, sMsg, sStylesheet, "call", iCallRec.GetKeyValue )
			Else
				iApp.UserMsg "FAX-Benachrichtigung für Aktionsregel Nr. " & iActionRec.GetValue("pkey") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If
        Case "Funkruf","SMS"
            sMsg = ActionMsg(iApp,iNetwork, iCallRec, iActionRec, sSubject, sDefaultStylesheet)
			sDummy= iNetwork.GetTable("appprofile").GetValueWhere("pkey","pkey","1")
			sStylesheet = iDoc_TemplateTable.GetRecord(0).GetValue("sms_xsl")
			If sStylesheet = "" Then sStylesheet = sDefaultStylesheet
            'bStatus = iApp.SendPage(sAddr, sSubject,bFeedback)
			If sAddr <> "" Then	
				bStatus = SaveMessage( iNetwork,  "sms://" & sAddr, sSubject, sMsg, sStylesheet, "call", iCallRec.GetKeyValue )
			Else
				iApp.UserMsg "SMS-Benachrichtigung für Aktionsregel Nr. " & iActionRec.GetValue("pkey") & " fehlgeschlagen da keine Adresse vorhanden ist." & Basic.Eoln$ & _
						     "Benachrichtigen Sie bitte einen Administrator."
			End If
        Case "Drucker", ""
			 iApp.UserMsg "Der AK konnte nicht benachrichtigt werden, weil die Stammdaten nicht stimmen." & Basic.Eoln$ & _ 
							" Bitte benachrichtigen Sie ihn von Hand.", ebInformation
        Case "Telefon"
			sAddr =  GetAppProfileValue(iNetwork, "custfeedbacklogin")
   			nPriority = iCallTable.MapEnumStrToInt( "priority",sPriority) +1
   			If nPriority > 3 Then nPriority = 3
            iApp.SendAlert sAddr, iApp.DBUser, sSubject, nPriority, _
                           "call", iCallRec.GetKeyValue,"Warnung"
        Case "Bearbeiter"
   			 If iCallRec.HasLinkedRecord("callworkgroup") Then
        	 	Set iWorkgroupRecord = iCallRec.GetLinkedRecord("callworkgroup")
            	 sPriority = iCallRec.GetValue("priority")
            	 nPriority = iCallTable.MapEnumStrToInt("priority", sPriority)
                 sMsg = ActionMsg(iApp,iNetwork, iCallRec, iActionRec, sSubject, sDefaultStylesheet)
	             NotifyWorkgroup iApp,iAlertNetwork, iNetwork, iWorkgroupRecord,  sSubject,  sMsg, "call", iCallRec.GetKeyValue
    	     End If
 
	 End Select
    Next i

    ' Clear the QBE data in action table
    iActionTbl.QBEClear
    Set iActionTbl = Nothing
	Set iAlertNetwork = Nothing 

End Sub
'----------------------------------------------------------------
Sub CallPostUpdate()
Dim iNetwork As DBNetwork
Dim iCallTable As DBTable
Dim iCallRec As DBRecord
Dim iApp As Application

    Set iApp = GetApp
    Set iNetwork = iApp.ContextNetwork
    Set iCallTable = iApp.ContextTable
    Set iCallRec = iApp.ContextRecord

	WriteCallDuration iApp, iNetwork, iCallRec
	If iCallRec.HasChanged( "callstatus" ) Then
   		DeleteAlerts iApp, iCallRec.GetValue( "pkey" )
	End If
	Set iDoc_TemplateTable = iNetwork.GetTable("doc_template")

    'ScheduleEscalations iApp, iNetwork, iCallTable, iCallRec
    RunActions iApp, iNetwork, iCallTable, iCallRec
    WriteEventRecord iApp, iNetwork, iCallRec
	bFirstLevelCloseCall = False
	CheckAutoClosed iApp, iNetwork,  iCallRec
	If bNotifyCustomer Then NotifyCustomer  iApp, iNetwork, iCallRec  ' Bei SL Overdue!
    Set iCallRec = Nothing
    Set iCallTable = Nothing
    Set iNetwork = Nothing
	Set iDoc_TemplateTable = Nothing
    Set iApp = Nothing
    Exit Sub

End Sub
'----------------------------------------------------------------




















































































































































































































































































































']]
'NAME = "Bookmark"
'TYPE = 0
'TEMPLATE = "Sub Bookmark()"
'TEXT = [[

'*****************************************************************************
' File:         Bookmark
' Purpose:      Set a bookmark on the current record
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Sub Bookmark()

Dim iApp As Application
Dim iGroup As SGroup
Dim iTable As DBTable
Dim iRec As DBRecord
Dim sTablename As String
Dim sUser As String
Dim sKey As String
Dim sMsg As String

    On Error GoTo bookmark_error_handler
    Set iApp = GetApp()

    Set iGroup = iApp.ContextGroup
    sTablename = iGroup.TableName
    Set iTable = iApp.ContextFocus.Network.GetTable(sTableName)
    If iGroup.Mode = MODE_FILLED Then
        Set iRec = iTable.GetRecord(iGroup.CurrentRecordNumber)
        'Set iRec = iApp.ContextRecord
        sKey = iRec.GetKeyValue
        If Len(sKey) Then
            sMsg = "Bookmark - " & sTablename & " " & sKey
            sUser = iApp.DBUser
            iApp.SendAlert sUser, sUser, sMsg, 0, sTablename, sKey
        End If
    End If
    Exit Sub

bookmark_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "Bookmark error " & CStr(Err) & ": " & Error$
End Sub
























































































































































































































































































































']]
'NAME = "AcceptCall"
'TYPE = 0
'TEMPLATE = "Sub AcceptCall()"
'TEXT = [[
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String
'*****************************************************************************
' File:         AcceptCall
' Purpose:      Make me the owner of the current call
' Copyright:    Quartess, 2002
' *****************************************************************************
Public bSendFAX As Boolean
Public bAcceptCall As Boolean

'-------------------------------------------------------------------
Global nResult As Integer
Global nSelection As Integer
Global AKList() As String
Const nAccept = 1
Function SelectAK(id$, action%, suppval%)
    Select Case action
        Case 2
            If id$ = "OK" Then
				nSelection = CInt(DlgValue("AKList")) 
                nResult = nAccept
            End If
    End Select
End Function

Begin Dialog UserDialog ,,318,96,"AK auswählen",.SelectAK
	GroupBox 2,3,314,70,"",.GroupBox
	Text 8,11,188,8,"Wählen Sie einen Auftragskoordinator  aus:",.Text
	ListBox 8,24,296,40,AKList,.AKList
	OKButton 140,78,40,14
End Dialog

Function SelectRoutingTable(iApp As Application, iNetwork As DBNetwork, iGroupBrowser As DBBrowser) As DBRecord
Dim d As UserDialog
Dim sWorkgroupKey As String
Dim sDesription As String
On Error GoTo Error_handler

    nRecs = iGroupBrowser.RecordCount
    ReDim AKList(nRecs - 1)

    For i = 0 To nRecs - 1
        sWorkgroupKey= iGroupBrowser.GetRecord(i).GetValue("groupmember.workgroupgroup")
 
        sName = iNetwork.GetTable("workgroup").GetValueWhere("name","pkey",sWorkgroupKey)
		SDesription = iNetwork.GetTable("workgroup").GetValueWhere("description","pkey",sWorkgroupKey)

        AKList(i) = sName & " | "  & sDesription  
    Next i
    Dialog d
	Set SelectRoutingTable = iGroupBrowser.GetRecord(nSelection)

	Exit Function
Error_handler:
    iApp.UserMsg "Acceptcall.SelectRoutingTable error " & CStr(Err) & ": " & Error$
End Function
'-------------------------------------------------------------------
Sub SetOwner(iApp As Application, iNetwork As DBNetwork, iGroup As SGroup)
Dim iWorkgroupTable As DBTable
Dim iGroupmemberTable As DBTable
Dim  iGroupmemberRecord  As DBRecord
Dim iGroupBrowser As DBBrowser
		Set iGroupBrowser = iNetwork.GetBrowser("grpmemberBrowser")
		Set iWorkgroupTable = iNetwork.GetTAble("workgroup")
		Set iGroupmemberTable = iNetwork.GetTAble("groupmember")
		iWorkgroupTable.QBEClear
		iWorkgroupTable.Clear
		iWorkgroupTable.QBESetValue "wrkgrptype", "OWNER"
		iGroupmemberTable.Clear
 		iGroupmemberTable.QBEClear
  	   	iGroupmemberTable.QBESetValue "employeegroup", iApp.CurrentUserKey
		
  		iGroupmemberTable.QBESetValue "accessallowed", "lesen/schreiben"
		'sSQL = "groupmember.employeegroup=" & iApp.CurrentUserKey &	" and groupmember.accessallowed=1 And " & _
		 '	   " groupmember.workgroupgroup=imsys.workgroup.pkey and imsys.workgroup.wrkgrptype =3"
		'iGroupmemberTable.SetWhere sSQL
		'iGroupmemberTable.Search 
		iGroupBrowser.Search "r_wkgrpemp", 2 
		If iGroupBrowser.RecordCount > 0 Then
		'We have a  record Lets Select selected.
			If iGroupBrowser.RecordCount > 1 Then
	   			 Set iGroupmemberRecord  = SelectRoutingTable(iApp, iNetwork, iGroupBrowser)
			Else
				Set iGroupmemberRecord  = iGroupBrowser.GetRecord(0)
			End If
        	iGroup.Change
       		iGroup.SetValue "callCallstatus", "Angenommen"
        	sWorkgroupKey= iGroupmemberRecord.GetValue("groupmember.workgroupgroup")
        	sName = iNetwork.GetTable("workgroup").GetValueWhere("name","pkey",sWorkgroupKey)

       		iGroup.SetForeignValue "callWorkgroup", sName, sWorkgroupKey
	        iGroup.Update
		Else
			iApp.UserMsg "Sie sind nicht als Mitarbeiter Typ 'OWNER' registriert. " & Basic.Eoln$ & _
						"Wenden Sie sich an einen Administrator.",ebInformation
		End If

End Sub
'-------------------------------------------------------------------------
Sub AcceptCall()

Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iGroup As SGroup
Dim iCallTable As DBTable
Dim iForm As SForm
Dim iCallRec As DBRecord
Dim iTable As DBTable
Dim iOwnerRec As DBRecord
Dim sOwner As String
Dim sOwnerKey As String
Dim sToday As String
Dim sAnswer As String
Dim bAddName As Boolean
Dim bNeedOwner As Boolean
 

    On Error GoTo acceptcall_error_handler

    Set iApp = GetApp()
    Set iNetwork = iApp.ContextFocus.Network()
    Set iGroup = iApp.ContextGroup
	iGroup.BtnClick "callRefresh"
    Set iGroup = iApp.ContextGroup
	Set iForm = iApp.ContextForm
	If GetAppProfileValue(iNetwork, "ak_is_owner") = "Ja" Then
	   bNeedOwner =True
	Else 
		bNeedOwner = False
	End If				   
    Set iCallTable = iNetwork.GetTable("call")

    ' If there is no backfilled record, get out.
    Set iCallRec = iGroup.GetCurrentRecord()
    If iCallRec Is Nothing Then
        iApp.ContextFocus.Message "Keine Meldung ausgewählt"
        Exit Sub
    End If

    ' You can't accept if the call is already owned
	
	If InStr("Neu|Durchgestellt|AK zugewiesen|Fehlgeroutet",iCallRec.GetValue("callstatus")) Then

	
		If iForm.Name="callEntryCaretaker" Or iForm.Name="callEntryCaretakerAK" And Not bNeedOwner Then
		   sAnswer = ""
		   	 sAnswer = InputBox$("Für wen soll die Meldung angenommen werden?","Meldung annehmen")
		    If sAnswer = ""	 Then Exit Sub
			bAddName = True
		Else
			bAddName = False
			nAnswer =iApp.UserResponseMsg( "Wollen Sie Meldung wirklich annehmen",ebQuestion + ebYesNo,"Meldung anehmen"	)
   	   		If nAnswer = ebNo Then
			   Exit Sub
	   		End If
		End If
		If bNeedOwner Then
			bAcceptCall = True
		   SetOwner iApp, iNetwork, iGroup	
		Else
        	iGroup.Change
       		iGroup.SetValue "callCallstatus", "Angenommen"
			bAcceptCall = True
	        iGroup.Update
			If bAddName Then
				sHistory =  Basic.Eoln$ &  " Meldung telefonisch angenommen von: " & sAnswer & 	Basic.Eoln$
				iApp.ContextRecord.SetLTValue "history", sHistory,2
		  		bSendFAX = True
				iApp.ContextTable.Commit
	   		End If
		End If
	Else 
        iApp.UserMsg "Die Meldung ist schon angenommen."
    End If
    Exit Sub

acceptcall_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "AcceptCall error " & CStr(Err) & ": " & Error$
End Sub























































































































































































































































































































']]
'NAME = "MyQueueSearch"
'TYPE = 0
'TEMPLATE = "Function MyQueueSearch() As Boolean"
'TEXT = [[
'*****************************************************************************
' File:         MyQueueSearch
' Purpose:      Search for calls assigned to my workgroups
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Function MyQueueSearch() As Boolean

    MyQueueSearch = False
End Function























































































































































































































































































































']]
'NAME = "OpenCallsByOrg"
'TYPE = 0
'TEMPLATE = "Function OpenCallsByOrg() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         OpenCallsByOrg
' Purpose:      Search for all open calls for the organization of the
'               current customer.
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Function OpenCallsByOrg() As Boolean

Dim iApp As Application
Dim iTable As DBTable
Dim iContextTable As DBTable
Dim iRecord As DBRecord
Dim nRecs As Integer
Dim sKey As String
Dim sSearchStr As String

    On Error GoTo opencalls_error_handler
    Set iApp = GetApp()
    Set iTable = iApp.ContextNetwork.GetTable("customer")
    Set iContextTable = iApp.ContextTable
    
    iApp.ContextFocus.ApplyCurrentConstraints "r_call"

    ' Clear the customer table so not to be used in search
    iTable.QBEClear

    ' Set the org key to be used in the search
    Set iTable = iApp.ContextNetwork.GetTable("organization")
    nRecs = iTable.RecordCount
    If nRecs > 0 Then
        Set iRecord = iTable.GetRecord(0)
        sKey = iRecord.GetKeyValue
        iTable.QBESetValue "pkey", sKey
    End If

    ' Set the call table status constraint
'!!??  Änderung von Mike
'    sSearchStr = "New|Assigned|Reassigned|Owned|Pending"
    sSearchStr = "!geschlossen"
    iContextTable.QBESetValue "callstatus", sSearchStr
    iApp.ContextBrowser.Search "r_call"

    ' Clear the QBE Data for iTable and ContextTable before exiting
    iTable.QBEClear
    iContextTable.QBEClear

    ' Return False to prevent standard search
    OpenCallsByOrg = False
    Exit Function

opencalls_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "OpenCallsByOrg error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for iTable and ContextTable before exiting
    If Not iTable Is Nothing Then
        iTable.QBEClear
    End If
    If Not iContextTable Is Nothing Then
        iContextTable.QBEClear
    End If

    OpenCallsByOrg = False
End Function




















































































































































































































































































































']]
'NAME = "MyAgentCallsSearch"
'TYPE = 0
'TEMPLATE = "Function MyAgentCallsSearch() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         MyAgentCallsSearch
' Purpose:      Search for calls that I am the agent for 
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Function MyAgentCallsSearch() As Boolean

Dim iApp As Application
Dim iTable As DBTable
Dim iContextTable As DBTable
Dim sSearchStr As String

    On Error GoTo mycalls_error_handler

    Set iApp = GetApp()
Dim sRelationset As String
	Select Case iApp.ContextFocus.Name
		Case "FWT-SMC Meldungserfassung","FWT-SMC Meldungserfassung AK"
			sRelationset = "r_call_entry" 
		Case "FWT-SMC Meldungsbearbeitung","Problemmanager", "Meldungsbearbeitung"
			sRelationset = "r_call" 
		Case Else
			sRelationset = "r_call_entry" 
	End Select

    Set iTable = iApp.ContextNetwork.GetTable("agent")
    Set iContextTable = iApp.ContextTable
    sSearchStr = "=" + iApp.DBUser
    iTable.QBESetValue "loginname", sSearchStr

    iApp.ContextFocus.ApplyCurrentConstraints sRelationset
    sSearchStr = "Neu|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen"
    iContextTable.QBESetValue "callstatus", sSearchStr

    iApp.ContextBrowser.Search sRelationset, 2	 ' QW_DCO_FILL_BOTH

    ' Clear the QBE Data for iTable and ContextTable before exiting
    iTable.QBEClear
    iContextTable.QBEClear

    ' Return False to prevent standard search
    MyAgentCallsSearch = False
    Exit Function

mycalls_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "MyAgentCallsSearch error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for iTable and ContextTable before exiting
    If Not iTable Is Nothing Then
        iTable.QBEClear
    End If
    If Not iContextTable Is Nothing Then
        iContextTable.QBEClear
    End If

    MyAgentCallsSearch = False
End Function














































































































































































































































































































































































']]
'NAME = "SearchOpenCalls"
'TYPE = 0
'TEMPLATE = "Function SearchOpenCalls() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         SearchOpenCalls
' Purpose:      Search for all open calls. Open calls are those
'               that have one of the following statuses:
'               New, Assigned, Reassigned, Owned or Pending
' Copyright:    Quintus Corporation, 1996
' Modification: Set additional search constraint to be sure
'               nobody can see calls of other workgroups
' *****************************************************************************
Function SearchOpenCalls() As Boolean

Dim iApp As Application
Dim iContextTable As DBTable
Dim sSearchStr As String

' BEGIN modification Jacek Margos
Dim iNetwork As DBNetwork
Dim iUserTbl As DBTable
Dim sRoles As String

Const ADMIN_ROLE = "CQADMIN" ' must be uppercase
Const SEPARATOR = ","

    On Error GoTo opencalls_error_handler


    Set iApp = GetApp()

Dim sRelationset As String
	Select Case iApp.ContextFocus.Name
		Case "FWT-SMC Meldungserfassung","FWT-SMC Meldungserfassung AK"
			sRelationset = "r_call_entry" 
		Case "FWT-SMC Meldungsbearbeitung","Problemmanager", "Meldungsbearbeitung"
			sRelationset = "r_call" 
		Case Else
			sRelationset = "r_call_entry" 
	End Select
    Set iContextTable = iApp.ContextTable
    iApp.ContextFocus.ApplyCurrentConstraints  sRelationset
    sSearchStr = "Neu|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen"

    Set iNetwork = iApp.ContextNetwork
    If iNetwork.HasTable("dbuser") Then
         ' if focus GruppenMeldungen
         sRoles = SEPARATOR & UCase$( iApp.GetUserGroups ) & SEPARATOR
         If InStr( 1, sRoles, SEPARATOR & ADMIN_ROLE & SEPARATOR ) = 0 Then
              ' we are not an administrator
              Set iUserTbl = iNetwork.GetTable( "dbuser" )
              ' constrain the search
              iUserTbl.QBESetValue "loginname", "^" & iApp.DBUser & "$"
         End If
    End If

    iContextTable.QBESetValue "callstatus", sSearchStr
    iApp.ContextBrowser.Search sRelationset, 2

    ' Clear the QBE Data for ContextTable before exiting
    iContextTable.QBEClear

    ' Return False to prevent standard search
    SearchOpenCalls = False
    Exit Function

opencalls_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "SearchOpenCalls error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for ContextTable before exiting
    If Not iContextTable Is Nothing Then
        iContextTable.QBEClear
    End If

    SearchOpenCalls = False
End Function














































































































































































































































































































































































']]
'NAME = "SafeSearch"
'TYPE = 0
'TEMPLATE = "Function SafeSearch() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         SafeSearch
' Purpose:      Ensure that a search is safe - that it has
'               constraints.
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Function SafeSearch() As Boolean

Dim iApp As Application
Dim bRes As Boolean
    On Error GoTo safesearch_error_handler
	SafeSearch = False
    Set iApp = GetApp()
	sBrowserName = iApp.ContextBrowser.Name
	n = InStr(sBrowserName,".")
	sBrowserName = Mid$(sBrowserName,n+1)
	Select Case sBrowserName
	Case "callBrowser", "callAKBrowser","UcallBrowser"
    	If iApp.ContextNetwork.HasConstraint("r_call_entry") Or _
    	   iApp.ContextNetwork.HasConstraint("r_call") Then
    	  	bRes = True
 		End If
	Case "customerintBrowser"
		If iApp.ContextNetwork.HasConstraint("r_customer") Then
    	  	bRes = True
 		End If
	Case "objectBrowser"
		If iApp.ContextNetwork.HasConstraint("r_object") Then
    	  	bRes = True
 		End If
	End Select
	If Not bRes Then
'!!: iApp.UserMsg
'        iApp.UserMsg "Empty Constraints for this search - aborted"
		iApp.UserMsg "keine Angaben für diese Suche - abgebrochen"
    End If
    'The following checks for constraints on the table only.
    'SafeSearch = iApp.ContextTable.HasConstraint
    SafeSearch = bRes

    Exit Function

safesearch_error_handler:
    SafeSearch = False
End Function














































































































































































































































































































































































']]
'NAME = "CallMakeDuplicate"
'TYPE = 0
'TEMPLATE = "Sub CallMakeDuplicate()"
'TEXT = [[
'*****************************************************************************
' Script:       CallMakeDuplicate
' Purpose:      Make this call a duplicate of another
' Copyright:    Quartess 2002
' *****************************************************************************
Sub	MakeNewLocation( iApp As Application,iNetwork As DBNetwork, iCallGroup As SGroup, sMasterLocationKey As String)
Dim iMasterLocationRec As DBRecord
Dim iLocationRec As DBRecord
Dim iLocationTable As DBTable
	Set iLocationTable = iNetwork.GetTable("location")

	iLocationTable.QBESetValue "pkey", sMasterLocationKey
	iLocationTable.Search
	If iLocationTable.RecordCount <> 1 Then	 Exit Sub
	Set iMasterLocationRec = iLocationTable.GetRecord(0)
   '	iLocationTable.Clear
	Set iLocationRec = iLocationTable.AddRecord
	iLocationRec.SetValue "baxis_key", iMasterLocationRec.GetValue("baxis_key")
	iLocationRec.SetValue "building_key", iMasterLocationRec.GetValue("building_key")
	iLocationRec.SetValue "buildingpart_key", iMasterLocationRec.GetValue("buildingpart_key")
	iLocationRec.SetValue "buildpartobj_key", iMasterLocationRec.GetValue("buildpartobj_key")
	iLocationRec.SetValue "description", iMasterLocationRec.GetValue("description")
	iLocationRec.SetValue "floor_key", iMasterLocationRec.GetValue("floor_key")
	iLocationRec.SetValue "gdsbaxis_key", iMasterLocationRec.GetValue("gdsbaxis_key")
	iLocationRec.SetValue "gdszaxis_key", iMasterLocationRec.GetValue("gdszaxis_key")
	iLocationRec.SetValue "note", iMasterLocationRec.GetValue("note")
	iLocationRec.SetValue "plane_key", iMasterLocationRec.GetValue("plane_key")
	iLocationRec.SetValue "room_key", iMasterLocationRec.GetValue("room_key")
	iLocationRec.SetValue "site_key", iMasterLocationRec.GetValue("site_key")
	iLocationRec.SetValue "orientation", iMasterLocationRec.GetValue("orientation")
	iLocationRec.SetValue "sitepart_key", iMasterLocationRec.GetValue("sitepart_key")
	iLocationRec.SetValue "zaxis_key", iMasterLocationRec.GetValue("zaxis_key")
	iLocationTable.Commit
	sNewLocationKey	 =iLocationRec.GetKeyValue()
	' Set Location Foreign Field:
    iLocationTable.Clear
	iLocationTable.QBESetValue "pkey", sNewLocationKey
	iLocationTable.Search
	If iLocationTable.RecordCount <> 1 Then	 Exit Sub
	Set iLocationRec = iLocationTable.GetRecord(0)

	iCallGroup.SetForeignValue "callLocation", iLocationRec.GetValue("description"), sNewLocationKey
End Sub

Sub CallMakeDuplicate()

Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iCallGroup As SGroup
Dim iFocus As SFocus
Dim iCallRec As DBRecord
Dim iMasterLocationRec As DBRecord
Dim sCallStatus As String
Dim sAccountingcodeValue As String
Dim sAccountingcodeKey As String
Dim sMasterKey As String
Dim sMasterPriority As String
Dim sMasterLocationKey As String
Dim sMasterAffectedPerson_key As String
Dim sMasterAffectedPerson As String
Dim sName As String
Dim nRecs As Integer
Dim sAgent As String
Dim sAgentKey As String
Dim sMasterCategoryKey As String

    On Error GoTo error_handler
    '-------------------------------------------------
    Set iApp = GetApp
    Set iNetwork = iApp.ContextNetwork
    Set iCallGroup = iApp.ContextGroup
    Set iCallRec = iCallGroup.GetCurrentRecord
    If iCallRec Is Nothing Then
        Exit Sub
    End If




    'If the current call has duplicates, watch out!
    'Search for any duplicate calls that are pointing to this call

	sSubCall = iCallRec.GetValue( "mastercall_key" )
	sCallStatus = iCallRec.GetValue("callstatus")

    If sSubCall <> "" And sSubCall <> "NULL" Then ' Uh Oh!
        iApp.UserMsg "Fehler - Untermeldung erzeugen nicht möglich:" &  _
                     " Call " & sMasterKey & _
                     " ist schon ein Untermeldung"
        Exit Sub
    End If
	' Check ob Subcall möglich
	If sCallstatus <> "Angenommen" Then 
        iApp.UserMsg "Untermeldung erzeugen nicht möglich:" &  _
                     " Meldung " & sMasterKey & _
                     " ist nicht im Status 'Angenommen'."
        Exit Sub
	End If
    sMasterKey = iCallRec.GetKeyValue
	sMasterPriority = iCallRec.GetValue("priority")
	sMasterLocationKey = iCallRec.GetValue("location_key")
	sMasterCategoryKey = iCallRec.GetValue("categorycall")
	If iCallRec.HasLinkedRecord("affectedperson") Then
		sMasterAffectedPerson_key = iCallRec.getLinkedRecord("affectedperson").GetValue("pkey")
		sMasterAffectedPerson = 	 iCallRec.getLinkedRecord("affectedperson").GetValue("fullname")
	End If
	If Len( iCallGroup.GetValue("callAccounting")) >0 Then
		sAccountingcodeValue = iCallGroup.GetValue("callAccounting")
		sAccountingcodeKey	= iCallGroup.GetForeignKey("callAccounting")
	End If
	If Len( iCallGroup.GetValue("callObject")) >0 Then
		sObjectValue = iCallGroup.GetValue("callObject")
		sObjectKey	= iCallGroup.GetForeignKey("callObject")
	End If
 
 '  Neuen Call erzeugen.
	Set iFocus = IApp.ContextFocus
	iFocus.Clear
	If iApp.Name = "imsys" Or iApp.Name = "testimsys" Then
   		iFocus.ShowForm "UTcallEntryCaretaker"
   		iFocus.GetForm("UTcallEntryCaretaker").GetGroup("category").SetValue "categoryPkey", sMasterCategoryKey
   		iFocus.GetForm("UTcallEntryCaretaker").GetGroup("category").BtnClick "categorySearch"
   		Set iCallGroup = iFocus.GetForm("UTcallEntryCaretaker").GetGroup("callEntry")
	Else
   		iFocus.ShowForm "callMngrCaretaker"
   		iFocus.GetForm("callMngrCaretaker").GetGroup("category").SetValue "categoryPkey", sMasterCategoryKey
   		iFocus.GetForm("callMngrCaretaker").GetGroup("category").BtnClick "categorySearch"
   		Set iCallGroup = iFocus.GetForm("callMngrCaretaker").GetGroup("callEntry")
	End If
	iCallGroup.BtnClick "callNew"
    sAgent = CurrentUserName(iNetwork, "agent")
    sAgentKey = CurrentUserKey(iNetwork, "agent")
	If 	sAgentKey <>"" And sAgentKey <> "NULL" Then
   		sAgentphone = iNetwork.GetTable("agent").GetValueWhere("phonecorr","pkey",sAgentKey)
   		iCallGroup.SetForeignValue "callCustomerInt",sAgent,sAgentKey
   		iCallGroup.SetValue "callOrigin","selbst"
		iCallGroup.SetValue "callCallbackmethod", iNetwork.GetTable("agent").GetValueWhere("communicatepref","pkey",sAgentKey)
	End If
	If 	 sMasterAffectedPerson <> "" Then
  		iCallGroup.SetForeignValue "callAffectedpersonFkey", sMasterAffectedPerson, sMasterAffectedPerson_key
	End If
	If sAccountingcodeValue <> "" Then
	   iCallGroup.SetForeignValue "callAccounting", sAccountingcodeValue, sAccountingcodeKey
	End If
	If sObjectValue <> "" Then
	   iCallGroup.SetForeignValue "callObject", sObjectValue, sObjectKey
	End If
	iCallGroup.SetValue "callMastercall", sMasterKey
	iCallGroup.SetValue "callPriority",	sMasterPriority
	' Create Location
	MakeNewLocation iApp, iNetwork,iCallGroup, sMasterLocationKey
    Exit Sub

error_handler:
    iApp.UserMsg "CallMakeDuplicate error " & CStr(Err) & ": " & Error$
End Sub














































































































































































































































































































































']]
'NAME = "CallSearchDups"
'TYPE = 0
'TEMPLATE = "Sub CallSearchDups()"
'TEXT = [[
'*****************************************************************************
' Script:       CallSearchDups
' Purpose:      Search for duplicates of given call
' Copyright:    Quintus Corporation, 1996
' Modification: Set additional search constraint to be sure
'               nobody can see calls of other workgroups
' *****************************************************************************

Sub CallSearchDups()

Dim iApp As Application
Dim iCallTable As DBTable
Dim iCallRec As DBRecord
Dim sDupKey As String

' BEGIN modification Jacek Margos
Dim iNetwork As DBNetwork
Dim iUserTbl As DBTable
Dim sRoles As String

Const ADMIN_ROLE = "CQADMIN" ' must be uppercase
Const SEPARATOR = ","
' END   modification Jacek Margos

    Set iApp = GetApp
    Set iCallTable = iApp.ContextTable
    Set iCallRec = iApp.ContextGroup.GetCurrentRecord
    If Not iCallRec Is Nothing Then
        sDupKey = iCallRec.GetValue("callcalldup")
        'sDupKey = iCallRec.GetKeyValue

        If Not((sDupKey = "-1") Or (sDupKey = "") Or (sDupKey = "NULL")) Then
            iCallTable.QBEClear
            'iApp.ContextFocus.ApplyCurrentConstraints "r_call"
            iCallTable.QBESetValue "callcalldup", sDupKey

' BEGIN modification Jacek Margos
            Set iNetwork = iApp.ContextNetwork
            If iNetwork.HasTable("dbuser") Then
                 ' if focus GruppenMeldungen
                 sRoles = SEPARATOR & UCase$( iApp.GetUserGroups ) & SEPARATOR
                 If InStr( 1, sRoles, SEPARATOR & ADMIN_ROLE & SEPARATOR ) = 0 Then
                      ' we are not an administrator
                      Set iUserTbl = iNetwork.GetTable( "dbuser" )
                      ' constrain the search
                      iUserTbl.QBESetValue "loginname", "^" & iApp.DBUser & "$"
                 End If
            End If
' END   modification Jacek Margos

            iApp.ContextBrowser.Search "r_call"

            ' Clear the QBE Data for iCallTable before exiting
            iCallTable.QBEClear
        End If
    End If

End Sub














































































































































































































































































































































']]
'NAME = "CallAge"
'TYPE = 0
'TEMPLATE = "Sub CallAge()"
'TEXT = [[
'*****************************************************************************
' Script:       CallAge
' Purpose:      Figure the age of the call (in business hours)
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************

Sub CallAge()
Dim iApp As Application
Dim iCallRec As DBRecord
Dim iGroup As SGroup
Dim sStr As String
Dim lInterval As Long


    Set iApp = GetApp
    Set iCallRec = iApp.ContextRecord
    Set iGroup = iApp.ContextGroup
    Set iCallRec = iApp.ContextGroup.GetCurrentRecord

'!!: "Closed" -> "geschlossen"
    If iCallRec.GetValue("callstatus") <> "geschlossen" Then 
'    If iCallRec.GetValue("callstatus") <> "Closed" Then 
        sStr = iCallRec.GetValue("datereported")
        If Len(sStr) Then
            lInterval = iApp.BusinessInterval(CDate(sStr), Now)
            iGroup.SetValue "callAge", iApp.SecondsToInterval(lInterval), True
        End If
    End If
End Sub













































































































































































































































































































































']]
'NAME = "ManualCallAction"
'TYPE = 0
'TEMPLATE = "Sub ManualCallAction()"
'TEXT = [[

' Possibility to run actions manually
' created by Jacek Margos, Quartess GmbH
' a right click menu runs this script and
' choose a notification from the list
'

'----------------------------------------------------------------
Function ActionMsg(iCallRec As DBRecord, _
    iActionRec As DBRecord, sSubject As String) As String
' Collect important information for a call and format it into an
' message.
'A.S. 31.05.01 Aktionsregel kann durch den Problem oder Aktionstext ergänzt werden.

Dim sMsg As String

    sMsg = sSubject & Chr(10) & Chr(10)

	sMsg = sMsg & iActionRec.GetValue("message")

    If iActionRec.GetValue("recordinfo") = "1" Then
'        sMsg = sMsg & iCallRec.GetRecordContent(True)
         sMsg = sMsg & Chr(10) & Chr(10)
	 sMsg = sMsg & iCallRec.GetValue("problemtext")
    End If
    
    If iActionRec.GetValue("recordinfo2") = "1" Then
         sMsg = sMsg & Chr(10) & Chr(10)
         sMsg = sMsg & iCallRec.GetValue("actiontext")
    End If
    

    ActionMsg = sMsg

End Function
'----------------------------------------------------------------
Function ActionAddr(iRecord As DBRecord, _
     iActionRec As DBRecord, sName As String) As String
' Build the action's address list 
Dim iRelRec As DBRecord
Dim sTo As String
Dim sMethod As String
Dim sAddr As String

    sTo = iActionRec.GetValue("recipient")
    sMethod = iActionRec.GetValue("method")

    Select Case sTo
'!!: "Customer" -> "Kunde"
    Case "Kunde"
'    Case "Customer"
        If iRecord.HasLinkedRecord("customer") Then
            Set iRelRec = iRecord.GetLinkedRecord("customer")
	    GoTo CustomerAddress
        ElseIf iRecord.HasLinkedRecord("customerint") Then
            Set iRelRec = iRecord.GetLinkedRecord("customerint")
	    GoTo EmployeeAddress
        End If
'!!: "Agent" -> "Mitarbeiter"
    Case "Mitarbeiter"
'    Case "Agent"
        If iRecord.HasLinkedRecord("agent") Then
            Set iRelRec = iRecord.GetLinkedRecord("agent")
	    GoTo EmployeeAddress
        End If
'!!: "Workgroup" -> "Arbeitsgruppe"
    Case "Arbeitsgruppe"
'    Case "Workgroup"
        If iRecord.HasLinkedRecord("callworkgroup") Then
            Set iRelRec = iRecord.GetLinkedRecord("callworkgroup")
            sAddr = iRelRec.GetValue("notificationaddr")
        End If
'!!: "CC List" -> "CC Liste"
    Case "CC Liste"
'    Case "CC List"
            sAddr = iRecord.GetValue("cclist")
    End Select

    ActionAddr = sAddr
    Exit Function


CustomerAddress:
    Select Case sMethod
    Case "Email"
        sAddr = iRelRec.GetValue("email")
    Case "FAX"
        sAddr = iRelRec.GetValue("fax")
        sName = iRelRec.GetValue("fullname")
    End Select

    ActionAddr = sAddr
    Exit Function

EmployeeAddress:
    Select Case sMethod
'!!: "Alert" -> "Signal"
    Case "Signal"
'    Case "Alert"
        sAddr = iRelRec.GetValue("loginname")
    Case "Email"
        sAddr = iRelRec.GetValue("email")
    Case "FAX"
        sAddr = iRelRec.GetValue("fax")
        sName = iRelRec.GetValue("fullname")
'!!: "Pager" -> "Funkruf"
    Case "Funkruf"
'    Case "Pager"
        sAddr = iRelRec.GetValue("pager")
    End Select

    ActionAddr = sAddr
End Function

'----------------------------------------------------------------
Sub NotifyWorkGroup(iApp As Application, _
    iCallTable As DBTable, iCallRec As DBRecord, _
    sMsg As String)
Dim sWorkgroupKey As String
Dim sPriority As String
Dim nPriority As Integer
Dim iRecord As DBRecord

    If iCallRec.HasLinkedRecord("callworkgroup") Then
        Set iRecord = iCallRec.GetLinkedRecord("callworkgroup")
        sWorkgroupKey = iRecord.GetKeyValue
        sPriority = iCallRec.GetValue("priority")
        nPriority = iCallTable.MapEnumStrToInt("priority", sPriority)

'!!??: "call" -> "Meldung"  Nicht ändern !!
'        iApp.NotifyWorkgroup Now, sWorkgroupKey, "Meldung", iCallRec.GetKeyValue, sMsg, nPriority
        iApp.NotifyWorkgroup Now, sWorkgroupKey, "call", iCallRec.GetKeyValue, sMsg, nPriority
    End If

End Sub

'----------------------------------------------------------------
Sub RunAction( iApp As Application, _
	iActionRec As DBRecord, _
	iCallRec As DBRecord )
Dim sPriority As String
Dim nPriority As Integer
Dim sSubject As String
Dim sMethod As String
Dim sAddr As String
Dim sName As String
Dim sMsg As String

	sPriority = iCallRec.GetValue( "priority" )
	nPriority = iCallRec.GetTable.MapEnumStrToInt( "priority", sPriority )
	sSubject = iCallRec.ParseString( CStr( iActionRec.GetValue( "subject" ) ) )
	sMethod = iActionRec.GetValue( "method" )
	sAddr = ActionAddr( iCallRec, iActionRec, sName )
	sMsg = ActionMsg( iCallRec, iActionRec, sSubject )
	If iActionRec.GetValue( "recipient" ) = "Arbeitsgruppe" Then
		NotifyWorkgroup iApp, iCallRec.GetTable, iCallRec, sSubject
		sMethod = ""
	End If
	If iActionRec.GetValue( "recipient" ) = "folgende Adresse" Then
		sAddr = iActionRec.GetValue( "notificationaddr" )
	End If

	Select Case sMethod
		Case "Signal"
			iApp.SendAlert sAddr, iApp.DBUser, sSubject, nPriority, _
				"call", iCallRec.GetKeyValue
		Case "Email"
			bStatus = iApp.SendMail( sAddr, sSubject, "", sMsg )
		Case "FAX"
			bStatus = iApp.SendFax( sAddr, sSubject, sName, sMsg )
		Case "Funkruf"
			bStatus = iApp.SendPage( sAddr, sSubject )
	End Select

End Sub
'----------------------------------------------------------------

Dim sList() As String
Dim nChoose As Integer

Function actions_FKT( ControlName$, Action%, SuppValue% )
	'Print ControlName$, Action%, SuppValue%
	If Action% = 1 Then
		nChoose = 0
	ElseIf Action% = 2 Then
		If ControlName = "List" Then
			nChoose = SuppValue%
		ElseIf ControlName = "Cancel" Then
			nChoose = -1
		End If
	End If
End Function


Begin Dialog ActionList 36,32,184,80,"Benachrichtigungen",.actions_FKT
	Text 8,4,100,8, "Aktions&name:"
	ListBox 8,16,100,50, sList, .List
	PushButton 133,4,45,14,"&OK",.OK
	PushButton 133,20,45,14,"&Abbrechen",.Cancel
End Dialog


Sub ManualCallAction
Dim iDialog As ActionList

Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iGroup As SGroup
Dim iCallRec As DBRecord
Dim iActionTbl As DBTable
Dim iActionRec As DBRecord
Dim sStatus As String
Dim sGrpKey As String
' changed by Jacek MArgos
Dim sCategoryKey As String
Dim sSoftwareKey As String

Dim nRecs As Long
Dim i As Long

	'Set iApp = GetObject( "", "CustomerQ.Application" )
	'Set iFocus = iApp.GetFocus( "Meldungserfassung" )
	'Set iNetwork = iFocus.Network
	'Set iForm = iFocus.GetForm( "callEntryInt" )
	'Set iGroup = iForm.GetGroup( "callEntry" )
	'ViewPort.Open
	Set iApp = GetApp
	Set iNetwork = iApp.ContextNetwork
	Set iGroup = iApp.ContextGroup
	Set iCallRec = iGroup.GetCurrentRecord
	If iCallRec Is Nothing Then
		iApp.UserMsg "nicht möglich - keine Meldung selektiert"
		Exit Sub
	End If
	sStatus = iCallRec.GetValue( "callstatus" )
	sGrpKey = iCallRec.GetValue( "workgroupcall" )
	' changed by Jacek Margos
	sCategoryKey = iCallRec.GetValue( "categorycall" )

	Set iActionTbl = iNetwork.GetTable( "callaction" )
	iActionTbl.Clear
	iActionTbl.QBEClear
	iActionTbl.QBESetValue "targettable", "Meldung"
	iActionTbl.QBESetValue "statusevent", sStatus
	iActionTbl.QBESetValue "confirmation", "1"
	If (sGrpKey = "-1") Or (sGrpKey = "") Or (sGrpKey = "NULL") Then
		' the call does not have a workgroup
		iActionTbl.QBESetValue "groupaction", "-1|NULL"
	Else
		' the call does have a workgroup
		iActionTbl.QBESetValue "groupaction", "-1|NULL|" & sGrpKey
	End If
	' changed by Jacek Margos
	If (sCategoryKey = "-1") Or (sCategoryKey = "") Or (sCategoryKey = "NULL") Then
		iActionTbl.QBESetValue "categoryaction", "-1|NULL"
	Else
		iActionTbl.QBESetValue "categoryaction", "-1|NULL|" & sCategoryKey
	End If
	iActionTbl.Search
	nRecs = iActionTbl.RecordCount

	If nRecs > 0 Then
		ReDim sList( nRecs - 1 )
		For i = 0 To nRecs - 1
			Set iActionRec = iActionTbl.GetRecord( i )
			sList( i ) = iActionRec.GetValue( "name" )
		Next
		i = Dialog( iDialog )
		If nChoose >= 0 Then
			Set iActionRec = iActionTbl.GetRecord( nChoose )
			RunAction iApp, iActionRec, iCallRec
		End If
	Else
		iApp.UserMsg "nicht möglich - keine Benachrichtigungen gefunden"
	End If
	Set iActionRec = Nothing
	iActionTbl.QBEClear
	iActionTbl.Clear
	Set iActionTbl = Nothing
End Sub




































































































































































































































































































































































']]
'NAME = "MyGroupQueueSearch"
'TYPE = 0
'TEMPLATE = "Function MyGroupQueueSearch() As Boolean"
'TEXT = [[
'*****************************************************************************
' File:         MyQueueSearch
' Purpose:      Search for calls assigned to my workgroups
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************
Function MyGroupQueueSearch() As Boolean

Dim iApp As Application
Dim iTable As DBTable
Dim iContextTable As DBTable
Dim iForm As SForm
Dim iFocus As SFocus
Dim iNetwork As DBNetwork
Dim sRelationset As String
Dim sSearchStr As String

    On Error GoTo myqueue_error_handler
    Set iApp = GetApp()
	Set iForm = iApp.ContextForm
	Set iFocus = iApp.ContextFocus

' Meister wollen vorher ein Clear
	iFocus.Clear

	Set iNetwork = iApp.ContextNetwork

	Set iTable = iNetwork.GetTable( "groupmember" )
	iTable.Clear
	Set iContextTable = iApp.ContextTable
	sSearchStr = "=" & CurrentUserKey( iNetwork, "employee" )
	iTable.QBESetValue "employeegroup", sSearchStr
	iTable.QBESetValue "accessallowed", "lesen/schreiben"
		sRelationset = "r_queues"
    iApp.ContextFocus.ApplyCurrentConstraints sRelationset
 
	Select Case iApp.ContextControlName
		Case "callMyAssignedCalls" ,"rmnuArray:4"
			If InStr( iApp.GetUserGroups, "CQ_PM" ) > 0 Then
				sSearchStr = "AK zugewiesen|Fehlgeroutet"
			Else
				sSearchStr = "AK zugewiesen"
			End If
		Case "callMyResolvedCalls" 
			sSearchStr = "Fertig gemeldet"
		Case "callMyAcceptedCalls" 
			sSearchStr = "Angenommen"
		Case "callMyCalls" 
			sSearchStr = "Angenommen|Fertig gemeldet|Dokumentiert"
		Case Else
			sSearchStr = "Neu|Durchgestellt|AK zugewiesen|Fehlgeroutet|Angenommen"
	End Select
    iContextTable.QBESetValue "callstatus", sSearchStr

    iApp.ContextBrowser.Search sRelationset , 2	 ' QW_DCO_FILL_BOTH

    ' Clear the QBE Data for iTable and ContextTable before exiting
    iTable.QBEClear
    iContextTable.QBEClear

    ' Return False to prevent standard search
    MyGroupQueueSearch = False
    Exit Function

myqueue_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "MyGroupQueueSearch error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for iTable and ContextTable before exiting
    If Not iTable Is Nothing Then
        iTable.QBEClear
    End If
    If Not iContextTable Is Nothing Then
        iContextTable.QBEClear
    End If

    MyGroupQueueSearch = False
End Function







































































































































































































































































































































']]
'NAME = "GenerateFAX"
'TYPE = 0
'TEMPLATE = "Sub GenerateFAX()"
'TEXT = [[
'*****************************************************************************
' Script:       GenerateFAX
' Purpose:      Preparing Fax
' Copyright:    Quartess, 2001 MDo
'*****************************************************************************
Declare Function CheckEmailAddress( sStr As String) As Boolean
Declare Function SaveMessage( iNetwork As DBNetwork,  sTo As String, sSubject As String, sMsg As String, sStylesheet As String, sTable As String, sKey As String) As Boolean

Declare Function ConvertFormular(iApp As Application,iNetwork As DBNetwork, sTemplateFile As String, bHTML As Boolean )  As String
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

'-------------------------------------------------------------------------------------
Dim iQNetwork       As  DBNetwork
Dim iQTable         As  DBTable
Dim iQRecord        As  DBRecord
Dim iNewQRec        As  DBRecord
Dim iDefaultTable   As  DBTable
Dim iDefaultNetwork As  DBNetwork
Dim iDefaultRecord  As  DBRecord
Dim sTemplateList() As String
Dim nTemplateNo     As Integer
Dim sMethod As String
Dim sRecipient As String
Dim sTemplatePkey() As String
Dim sMethodDropListBox() As String
Dim sRecipientDropListBox() As String
Dim sAddress As String
Dim bCancel As Boolean
Dim sTablename As String

Function GetDefaultValue() As String
Dim iRelRec As DBRecord
Dim sAddr As String
	sAddr =""
    Select Case sRecipient
    Case "Kunde"
		Select Case  right$(iDefaultTable.Name ,4)
			Case "call"
        		If iDefaultRecord.HasLinkedRecord("customerint") Then
      	     		 Set iRelRec = iDefaultRecord.GetLinkedRecord("customerint")
	 	  		    Select Case sMethod
	  	 		    Case "Email"
	  			        sAddr = iRelRec.GetValue("emailcorr")
						If sAddr ="" Then sAddr ="@daimlerchrysler.com"
	   			    Case "FAX", "Fax"
				        sAddr = iRelRec.GetValue("faxcorr")
	  			    Case "Funkruf","SMS"
	  			        sAddr = iRelRec.GetValue("pager")
	 			    End Select
 		       End If
			Case "task"
        		If iDefaultRecord.HasLinkedRecord("call") Then
      	     		 Set iRelRec = iDefaultRecord.GetLinkedRecord("call")
        	 		If iRelRec.HasLinkedRecord("customerint") Then
      	     	   		 Set iRelRec = iRelRec.GetLinkedRecord("customerint")
			 	
	 	  	  		    Select Case sMethod
	  	 	   		    Case "Email"
	  		   		        sAddr = iRelRec.GetValue("emailcorr")
					    	If sAddr ="" Then sAddr ="@daimlerchrysler.com"
	   		   		    Case "FAX", "Fax"
				 	       sAddr = iRelRec.GetValue("faxcorr")
	  				    Case "Funkruf","SMS"
	  			  	      sAddr = iRelRec.GetValue("pager")
	 			 	   End Select
 		 	     	End If
				 End If
	   	End Select
    Case "Centerleiter"
		  sCenterKey =GetAppProfileValue(iDefaultNetwork,"employee_key")
		   If sCenterKey = "" Then
				GetDefaultValue =""
			 Exit Function
		   End If
		  sAddr=""	
	 	  Select Case sMethod
	  	 		    Case "Email" 
	  			        sAddr = iDefaultNetwork.GetTable("customerint").GetValuewhere("emailcorr","pkey",sCenterKey)
						If sAddr ="" Then sAddr ="@daimlerchrysler.com"
	   			    Case "FAX", "Fax"
	  			        sAddr = iDefaultNetwork.GetTable("customerint").GetValuewhere("faxcorr","pkey",sCenterKey)
	  			    Case "Funkruf","SMS"
	  			        sAddr = iDefaultNetwork.GetTable("customerint").GetValuewhere("pager","pkey",sCenterKey)
	 	  End Select

    Case "Gruppe"
		Select Case right$(iDefaultTable.Name,4) 
			Case "call"
        If iDefaultRecord.HasLinkedRecord("callworkgroup") Then
            Set iRelRec = iDefaultRecord.GetLinkedRecord("callworkgroup")
		    Select Case sMethod
		    Case "Email"
		        sAddr = iRelRec.GetValue("email")
				If sAddr ="" Then sAddr ="@daimlerchrysler.com"

		    Case "FAX", "Fax"
		        sAddr = iRelRec.GetValue("fax")
		    Case "Funkruf","SMS"
		        sAddr = iRelRec.GetValue("phone")
		    End Select
 		       End If
			Case "task"
      		  If iDefaultRecord.HasLinkedRecord("taskworkgroup") Then
            Set iRelRec = iDefaultRecord.GetLinkedRecord("taskworkgroup")
		    Select Case sMethod
		    Case "Email"
		        sAddr = iRelRec.GetValue("email")
				If sAddr ="" Then sAddr ="@daimlerchrysler.com"

		    Case "FAX", "Fax"
		        sAddr = iRelRec.GetValue("fax")
		    Case "Funkruf","SMS"
		        sAddr = iRelRec.GetValue("phone")
		    End Select
 		       End If
	   		End Select

	End Select
	GetDefaultValue = sAddr
End Function

Function Dlg_Fkt( ControlName$, Action%, SuppValue% )

Select Case Action%
	Case 1 ' First time open Dialog
		nTemplateNo=0
		sMethod = sMethodDropListBox(0)
		sRecipient =sRecipientDropListBox(0)
		 DlgText "AddressTextBox", GetDefaultValue

	Case 2 ' something clicked
		Select Case ControlName$
			Case "OK"
			  bCancel = False
			  sAddress= DlgText$("AddressTextBox")	
			Case "Cancel"
				Dlg_Fkt=0
			  bCancel = True

			Case "RecipientDropListBox"
			   sRecipient =sRecipientDropListBox(SuppValue%)
			   DlgText "AddressTextBox", GetDefaultValue
			Case "MethodDropListBox"
			   sMethod =sMethodDropListBox(SuppValue%)
			   DlgText "AddressTextBox", GetDefaultValue
			Case "TemplateListBox"
				nTemplateNo = SuppValue%
		End Select
End Select
End Function
'-------------------------------------------------------------------
Sub GenerateFAX()
Dim iApp As Application
Dim nRecs,i,r1 As Integer
ReDim sTemplateList(0)
ReDim sTemplatePkey(0)
ReDim sMethodDropListBox(2)
ReDim sRecipientDropListBox(2)
Dim iXMLTable As DBTable
Dim bStatus As Boolean
Dim sMsg As String 
Dim sStylesheet As String
Dim sXML_key As String
Dim sDirectory As String
Dim sFileName As String
Dim nChanel As Integer

On Error GoTo Notification_error
sMethodDropListBox(0) ="Email"
sMethodDropListBox(1) ="FAX"
sMethodDropListBox(2) ="SMS"
sRecipientDropListBox(1) ="Kunde"
sRecipientDropListBox(0) ="Gruppe"
sRecipientDropListBox(2) ="Centerleiter"

Begin Dialog GetTemplateDialog ,,248,107,"Nachricht",.Dlg_Fkt
	OKButton 198,8,40,14
	CancelButton 197,28,40,14
	ListBox 4,44,172,56,sTemplateList,.TemplateListBox
	DropListBox 4,8,68,64,sMethodDropListBox,.MethodDropListBox
	DropListBox 101,8,76,40,sRecipientDropListBox,.RecipientDropListBox
	Text 80,9,20,12,"an",.Text1
	Text 4,28,32,8,"Adresse:",.Text2
	TextBox 40,25,137,12,.AddressTextBox
End Dialog

	Set iApp=GetApp()
	Set iDefaultNetwork = iApp.ContextNetwork
	Set iDefaultRecord = iApp.ContextGroup.GetCurrentRecord
	If Not iDefaultRecord Is Nothing Then
	   	Set iDefaultTable = iDefaultRecord.GetTable
   	Else
   	   	Set iDefaultTable = iDefaultNetwork.GetTable( iApp.ContextGroup.TableName() )
	End If
	Set iQTable = iDefaultNetwork.GetTable( "doc_template" )
	iQTable.Clear
	iQTable.QBEClear
	If right$(iDefaultTable.Name,4) ="call" Then iQTable.QBESetValue "use_in", "überall|Meldung"
	If right$(iDefaultTable.Name,4) ="task" Then iQTable.QBESetValue "use_in", "überall|Auftrag"
	iQTable.Search
	nRecs = iQTable.RecordCount
	If nRecs > 0 Then
		nRecs = nRecs - 1
		ReDim sTemplateList( nRecs )
		ReDim sTemplatePkey( nRecs )
		For i=0 To nRecs 
			Set iQRecord = iQTable.GetRecord( i )
			sTemplateList( i ) = iQRecord.GetValue( "name" )
			sTemplatePkey( i ) = iQRecord.GetValue("pkey")
		Next i
		Set iQRecord = Nothing
	Else
		iApp.UserMsg "Es stehen keine Vorlagen zur Verfügung"
		Exit Sub
	End If
	bCancel = False
	Dim GetTemplate As GetTemplateDialog
	Do
		r1% = Dialog( GetTemplate )
		If Not bCancel And Len(sAddress) = 0 Then
		   iApp.UserMsg "Es ist keine Adresse angegeben."	
		   r1%=3	
		End If
		If Not bCancel And sMethod ="Email"  Then
		   If  Not CheckEmailAddress(sAddress) Then	r1%=3		   
		End If

	Loop Until r1% <> 3
	
	If bCancel Then GoTo  Exit_Sub
		 sDoc_key =	iQTable.GetRecord(nTemplateNo).GetValue("pkey")
   		iQTable.Clear
   		iQTable.QBEClear
		iQTable.QBESetValue "pkey", sDoc_key
		iQTable.Search
		 sStylesheet = iQTable.GetRecord(0).GetValue("xsl_stylesheet")
    	 sXML_key = iQTable.GetRecord(0).GetValue("xml_template_key") 
    	If sXML_key <> "" And sXML_key <> "NULL" Then
			Set iXMLTable = iDefaultNetwork.GetTable("xml_template")
		 	sMsg = iXMLTable.GetValueWhere("xmltext","pkey",sXML_key)
			sMsg = ConvertFormular(iApp,iDefaultNetwork,  sMsg,true)
		Else
	   		sMsg ="<doc>Fehler! Kein Text!</doc>"
			sStylesheet= "default.xsl"
		End If
		
		If	 sMethod <>"Drucken" Then
			nAnswer =iApp.UserResponseMsg( "Wollen Sie Meldung wirklich versenden",ebQuestion + ebYesNo,"Meldung versenden"	)
   	   		If nAnswer = ebNo Then
			   Exit Sub
	   		End If
		End If

      sTablename =right$(iDefaultTable.Name,4)
	 Select Case sMethod
        Case "Email"
			sStylesheet = iQTable.GetRecord(0).GetValue("email_xsl")
			bStatus = SaveMessage( iDefaultNetwork,  "email://" & sAddress, "email://" & sAddress, sMsg, sStylesheet, sTablename, iDefaultRecord.GetKeyValue )
        Case "FAX","Fax"
			sStylesheet = iQTable.GetRecord(0).GetValue("fax_xsl")
			bStatus = SaveMessage( iDefaultNetwork,  "rightfax://" & sAddress, "rightfax://" & sAddress, sMsg, sStylesheet, sTablename, iDefaultRecord.GetKeyValue )
        Case "Funkruf","SMS"
			sStylesheet = iQTable.GetRecord(0).GetValue("sms_xsl")
			bStatus = SaveMessage( iDefaultNetwork,  "sms://" & sAddress, "sms://" & sAddress, sMsg, sStylesheet, sTablename, iDefaultRecord.GetKeyValue )
        Case "Drucken", ""
			If sDirectory = "" Then
				sDirectory = Environ( "TMP" )
			End If
			If sDirectory = "" Then
				sDirectory = "C:"
			End If
			If Right$( sDirectory, 1 ) <> "\" Then
				sDirectory = sDirectory & "\"
			End If
			sFileName = sDirectory & "doc" & Format(Now(), "yyyymmdd-hhnnss") & ".XML"
			nChanel = FreeFile()	' Write
			Open sFilename For Output  As nChanel
					Print # nChanel, sMsg 
			Close nChanel 
	        iApp.SetURL sFileName
	        iApp.ShowHTMLBrowser
		'	Sleep(2000)
		'	On Error Resume Next
		'	kill sDirectory & "*.XML"
		'	On Error GoTo Notification_error
	 End Select
	 If bStatus And sMethod <> "Drucken" Then
		iApp.UserMsg  sMethod & "-Nachricht wird an " & sAddress & " versandt"
	 End If 
Exit_Sub:
	Set iQNetwork = Nothing
Exit Sub

Notification_error:
	If Not( iQNetwork Is Nothing ) Then
		Set iQNetwork = Nothing
	End If
	iApp.UserMsg "TroubleTicket error " & CStr( Err ) & ": " & Error$
End Sub
























































































































































































































































































































']]
'NAME = "GotoCall"
'TYPE = 0
'TEMPLATE = "Sub GotoCall()"
'TEXT = [[
'*****************************************************************************
'Script:       GotoCall
'Purpose:      GUI script to jump to CallEntry form
'Type:	       GUI Rule
'Copyright:    Quartess MDo, 2002
'*****************************************************************************

Sub GotoCall()
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iLocationGroup As SGroup
Dim iObjectGroup As SGroup
Dim iObjCategoryGroup As SGroup
Dim iCategoryGroup As SGroup
Dim iCallGroup As SGroup
Dim iTable As DBTable
Dim iForm As SForm
Dim sKey As String
Dim sName As String	

	On Error GoTo ERROR_HANDLER
    '----------------------------------
    Set iApp = GetApp()
	Set iNetwork = iApp.ContextNetwork
	Select Case iApp.ContextForm.Name
	Case  "location", "object"
		Set iObjectGroup = iApp.Contextfocus.GetForm("object").GetGroup("object")
		Set iObjCategoryGroup = iApp.Contextfocus.GetForm("object").GetGroup("objectcategory")
		If iApp.ContextFocus.Name = "FWT-SMC Meldungserfassung" Then
			iApp.ContextFocus.ShowForm "callEntryCaretaker"
			Set iCategoryGroup = iApp.Contextfocus.GetForm("callEntryCaretaker").GetGroup("category")
	   		Set iCallGroup = iApp.Contextfocus.GetForm("callEntryCaretaker").GetGroup("callEntry")
		Else
			iApp.ContextFocus.ShowForm "callEntryCaretakerAK"
			Set iCategoryGroup = iApp.Contextfocus.GetForm("callEntryCaretakerAK").GetGroup("category")
			Set iCallGroup = iApp.Contextfocus.GetForm("callEntryCaretakerAK").GetGroup("callEntry")

		End If

		If iObjCategoryGroup.Mode = MODE_FILLED Then ' Category füllen!
	  	 iCategoryGroup.BtnClick "categoryClear"	
	   	 sCategoryKey = iObjCategoryGroup.GetValue("categoryPkey")
	   	 iCategoryGroup.SetValue "categoryPkey", sCategoryKey	
	   	 iCategoryGroup.BtnClick "categorySearch"
		End If
   		sAccountingcode = iObjectGroup.GetValue("objectAccountingcode")
  		If Len(sAccountingcode) >0 And iCallGroup.Mode <> Mode_Filled And iCallGroup.GetValue("callAccounting") = "" Then
  			iCallGroup.SetForeignValue "callAccounting", sAccountingcode, iObjectGroup.GetForeignKey("objectAccountingcode") 
 			'  Hier muß Tabelle accountingcode gefüllt werden!	- Wegen Standardvertrag!
  		    Set iTable = iNetwork.GetTable("accountingcode")
 			iTable.QBESetValue "code" , sAccountingcode
		   	iTable.Search
		End If
		Exit Sub
	Case "locationAK"
			sFormName = "callMngrCaretaker"
	Case "UTorgcustomerInt"
		sFormName = "UTcallEntryCaretaker"
	Case "locationAgent"
		If iApp.ContextFocus.Name = "FWT-SMC Meldungserfassung" Then
			sFormName = "callEntryCaretaker"
		Else
			If iApp.ContextFocus.Name = "Meldungsbearbeitung" Then
		  		sFormName = "UTcallEntryCaretaker"
	   		Else
				sFormName = "callEntryCaretakerAK" 
			End If
		End If
End Select
	 iApp.Contextfocus.ShowForm sFormName 
	 Exit Sub	
Error_handler:
    iApp.UserMsg "GotoCall error " & CStr(Err) & ": " & Error$

Exit_Sub:
End Sub













































































































































































































































































































']]
'NAME = "CallLocationSearch"
'TYPE = 0
'TEMPLATE = "Function CallLocationSearch() As Boolean"
'TEXT = [[
Function CallLocationSearch() As Boolean
Dim iApp As Application
Dim iGroup As SGroup

    Set iApp = GetApp
	Set iGroup = iApp.ContextGroup()
	If iGroup.Mode = MODE_NEW Or iGroup.Mode = MODE_UPDATE Then 
		iApp.UserMsg "Sie müssen einen neuen Störungsort angeben", ebExclamation
		CallLocationSearch = False
	Else
		CallLocationSearch = True
	End If
 End Function













































































































































































































































































































']]
'NAME = "CallMisDispatched"
'TYPE = 0
'TEMPLATE = "Sub CallMisDispatched()"
'TEXT = [[
'*****************************************************************************
' File:         AcceptCall
' Purpose:      Make me the owner of the current call
' Copyright:    Quartess, 2002
' *****************************************************************************
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

Sub CallMisDispatched()

Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iGroup As SGroup
Dim iCallTable As DBTable
Dim iCallRec As DBRecord
Dim iOwnerTable As DBTable
Dim iOwnerRec As DBRecord
Dim sOwner As String
Dim sOwnerKey As String
Dim sToday As String

    On Error GoTo acceptcall_error_handler

    Set iApp = GetApp()
    Set iNetwork = iApp.ContextFocus.Network()
    Set iGroup = iApp.ContextGroup				   
'!!: "call" -> "Meldung"
'    Set iCallTable = iNetwork.GetTable("Meldung")
    Set iCallTable = iNetwork.GetTable("call")

    ' If there is no backfilled record, get out.
    Set iCallRec = iGroup.GetCurrentRecord()
    If iCallRec Is Nothing Then
        iApp.ContextFocus.Message "Keine Meldun ausgewählt"
        Exit Sub
    End If

    ' You can't accept if the call is already owned

	If iGroup.GetValue("callCallstatus")="AK zugewiesen" Then
		sPkey = GetAppProfileValue(iNetwork, "problemmanager_key")
		If sPkey <> "" And sPkey <> "NULL" Then
	   	    iGroup.Change
	        iGroup.SetValue "callDateowned", ""
	        iGroup.SetValue "callCallstatus", "Fehlgeroutet"
			sName = iNetWork.GetTable("workgroup").GetValueWhere("name","pkey",spkey)
        	iGroup.SetForeignValue "callWorkgroup", sName, sPkey
			iGroup.Update
		Else 
			iApp.UserMsg "Es ist kein Problemmanager definiert" & Basic.Eoln$ & _
						 "Benachrichtigen Sie bitte den SMC Administrator", ebCritical
		End If
    End If
    Exit Sub

acceptcall_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "AcceptCall error " & CStr(Err) & ": " & Error$
End Sub










































































































































































































































































































']]
'NAME = "GotoRecord"
'TYPE = 0
'TEMPLATE = "Sub GotoRecord()"
'TEXT = [[
'*****************************************************************************
'Script:       GotoLocation
'Purpose:      GUI script to jump to CallEntry form
'Type:	       GUI Rule
'Copyright:    Quartess MDo, 2002
'*****************************************************************************

Sub GotoRecord()
Dim iApp As Application
Dim iCallGroup As SGroup
Dim iTaskGroup As SGroup
Dim iForm As SForm
Dim sKey As String
Dim sName As String	
Dim iIFB As SIFBrowser
Dim lCurrentRow As Long

	On Error GoTo ERROR_HANDLER
    '----------------------------------
    Set iApp = GetApp()
    Set iIFB = iApp.ContextIFBrowser
	
    ' Set variables for what we are currently processing.
    lCurrentRow = iApp.ContextIFBrowserRow

    If  iIFB.RowState(lCurrentRow) = ROW_FILLED Then 
'		msgbox iIFB.Name
		Select Case iIFB.Name
		Case "opencallsIFBrowser", "obj_opencallsIFBrowser"
			sKey = iIFB.GetCellValue( lCurrentRow, "browserPkey" )
			If sKey ="" Then Exit Sub
			If iApp.ContextFocus.Name = "FWT-SMC Meldungserfassung" Then
		  		iApp.ContextFocus.ShowForm "callEntryCaretaker"
	   			Set iCallGroup = iApp.Contextfocus.GetForm("callEntryCaretaker").GetGroup("callEntry")
			Else
				If iApp.ContextFocus.Name = "Meldungsbearbeitung" Then
		  			iApp.ContextFocus.ShowForm "UTcallEntryCaretaker"
	   				Set iCallGroup = iApp.Contextfocus.GetForm("UTcallEntryCaretaker").GetGroup("callEntry")
		   		Else
			  		iApp.ContextFocus.ShowForm "callEntryCaretakerAK"
	   		  		Set iCallGroup = iApp.Contextfocus.GetForm("callEntryCaretakerAK").GetGroup("callEntry")
	   	   		End If
	   		End If
	   		iApp.ContextFocus.Clear
	   		iCallGroup.SetValue "callKey", sKey
			iCallGroup.BtnClick "callSearch"

		Case "callduplicateIFBrowser"
			sKey = iIFB.GetCellValue( lCurrentRow, "browserPkey" )
			If sKey ="" Then Exit Sub
	   		iApp.ContextFocus.ShowForm "callMngrCaretaker"
	   		Set iCallGroup = iApp.Contextfocus.GetForm("callMngrCaretaker").GetGroup("callEntry")
	   		iApp.ContextFocus.Clear
	   		iCallGroup.SetValue "callKey", sKey
			iApp.ContextFocus.ApplyCurrentConstraints "r_call"
			iApp.ContextBrowser.Search "r_call",2
		   	iCallGroup.SetControlVisibility "callKey", True

		Case "taskIFBrowser"
			sKey = iIFB.GetCellValue( lCurrentRow, "browserPkey" )
			If sKey ="" Then Exit Sub
	   		iApp.ContextFocus.ShowForm "taskdocumentation"
	   		Set iTaskGroup = iApp.Contextfocus.GetForm("taskdocumentation").GetGroup("task")
			iApp.ContextFocus.Clear		
	 	   	iTaskGroup.SetValue "taskKey", sKey
			iTaskGroup.BtnClick "taskSearch"
		   	iTaskGroup.SetControlVisibility "taskKey", True	

		Case "UTtaskIFBrowser"
			sKey = iIFB.GetCellValue( lCurrentRow, "browserPkey" )
			If sKey ="" Then Exit Sub
	   		iApp.ContextFocus.ShowForm "UTtask"
	   		Set iTaskGroup = iApp.Contextfocus.GetForm("UTtask").GetGroup("task")
			iApp.ContextFocus.Clear		
	 	   	iTaskGroup.SetValue "taskKey", sKey
			iTaskGroup.BtnClick "taskSearch"
		   	iTaskGroup.SetControlVisibility "taskKey", True	
		
		Case "callUTsubcallIFBrowser"
			sKey = iIFB.GetCellValue( lCurrentRow, "browserPkey" )
			If sKey ="" Then Exit Sub
	   		iApp.ContextFocus.ShowForm "UTcallMngrDocument"
	   		Set iCallGroup = iApp.Contextfocus.GetForm("UTcallMngrDocument").GetGroup("callEntry")
	   		iApp.ContextFocus.Clear
	   		iCallGroup.SetValue "callKey", sKey
			iApp.ContextFocus.ApplyCurrentConstraints "r_call"
			iApp.ContextBrowser.Search "r_call",2
		   	iCallGroup.SetControlVisibility "callKey", True
	
		End Select
	End If
Exit Sub
Error_handler:
    iApp.UserMsg "GotoRecord error " & CStr(Err) & ": " & Error$

Exit_Sub:
End Sub







































































































































































































































































































']]
'NAME = "SearchCallbackCalls"
'TYPE = 0
'TEMPLATE = "Function SearchCallbackCalls() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         SearchCallbackCalls
' Purpose:      Search for all callswith status Rückruf
' *****************************************************************************
Function SearchCallbackCalls() As Boolean

Dim iApp As Application
Dim iContextTable As DBTable


    On Error GoTo opencalls_error_handler

    Set iApp = GetApp()

	iApp.ContextFocus.Clear
    iApp.ContextTable.QBESetValue "callstatus", "Rückruf"
    iApp.ContextBrowser.Search "r_call_entry"

    ' Clear the QBE Data for ContextTable before exiting
    iApp.ContextTable.QBEClear

    ' Return False to prevent standard search
    SearchCallbackCalls = False
    Exit Function

opencalls_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "SearchCallbackCalls error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for ContextTable before exiting
    If Not iContextTable Is Nothing Then
        iContextTable.QBEClear
    End If

    SearchCallbackCalls = False
End Function







































































































































































































































































































']]
'NAME = "GotoCustomer"
'TYPE = 0
'TEMPLATE = "Sub GotoCustomer()"
'TEXT = [[
'*****************************************************************************
'Script:       GotoLocation
'Purpose:      GUI script to jump to customerint form after added a call
'Type:	       GUI Rule
'Copyright:    Quartess MDo, 2002
'*****************************************************************************

Sub GotoCustomer()
Dim iApp As Application
Dim iCallGroup As SGroup
Dim iForm As SForm
Dim sKey As String
Dim sName As String	

	On Error GoTo ERROR_HANDLER
    '----------------------------------
    Set iApp = GetApp()
	Set iCallGroup = iApp.ContextGroup
	Set iForm = iApp.ContextForm
	If iCallGroup.Mode <> MODE_UPDATE And iCallGroup.Mode <> MODE_NEW Then
		iApp.Contextfocus.Clear
		If iForm.Name = "callEntryCaretakerAK" Then
			iApp.ContextFocus.ShowForm "orgcustomerIntAK"
		End If
	End If

Exit Sub
Error_handler:
    iApp.UserMsg "GotoCustomer error " & CStr(Err) & ": " & Error$

Exit_Sub:
End Sub






































































































































































































































































































']]
'NAME = "GotoTaskAdd"
'TYPE = 0
'TEMPLATE = "Sub GotoTaskAdd()"
'TEXT = [[
'*****************************************************************************
'Script:       GotoTaskAdd
'Purpose:      GUI script to jump to TaskAdd form after modified a call
'Type:	       GUI Rule
'Copyright:    Quartess MDo, 2002
'*****************************************************************************

Sub GotoTaskAdd()
Dim iApp As Application
Dim iGroup As SGroup
Dim iCallGroup As SGroup
Dim iTaskGroup As SGroup
Dim iForm As SForm
Dim sKey As String
Dim sPriority As String
Dim sName As String	

	On Error GoTo ERROR_HANDLER
    '----------------------------------
    Set iApp = GetApp()
	Set iGroup = iApp.ContextGroup
	If iGroup.Mode <> MODE_UPDATE And iGroup.Mode <> MODE_NEW Then
	  	   sCallStatus = iGroup.GetValue(iGroup.GUIName("callstatus") )
	  		If sCallStatus = "Geschlossen" Then 
   			  	iApp.UserMsg "Für geschlossene Meldungen dürfen keine Aufträge angelegt werden.", ebCritical
				Exit Sub	
			End If
	  		If sCallStatus <> "Angenommen" Then 
   			  	iApp.UserMsg "Um Aufträge anzugelegen, muß die Meldung angenommen sein."
				Exit Sub	
			End If
		sCallkey = iGroup.GetValue(iGroup.GUIName("pkey") )
		sPriority =  iGroup.GetValue(iGroup.GUIName("priority"))
		If iApp.Name = "imsys" Or iApp.Name = "testimsys" Then
			iApp.ContextFocus.ShowForm "UTtask"
			Set iCallGroup = iApp.ContextFocus.GetForm("UTtask").GetGroup( "call" )
			Set iTaskGroup = iApp.ContextFocus.GetForm("UTtask").GetGroup( "task" )
		Else
			iApp.ContextFocus.ShowForm "taskadd"
			Set iCallGroup = iApp.ContextFocus.GetForm("taskadd").GetGroup( "call" )
			iCallGroup.BtnClick "callRefresh"
			Set iTaskGroup = iApp.ContextFocus.GetForm("taskadd").GetGroup( "task" )

		End If
		If iTaskGroup.Mode <> MODE_UPDATE And iTaskGroup.Mode <> MODE_NEW Then
			iTaskGroup.Clear
			iTaskGroup.SetForeignValue "taskCall", sCallkey,sCallkey
			iTaskGroup.SetValue "taskPriority", sPriority
		End If
	End If

Exit Sub
Error_handler:
    iApp.UserMsg "GotoTaskdocumentation error " & CStr(Err) & ": " & Error$

Exit_Sub:
End Sub

































































































































































































































































































']]
'NAME = "SetCallStatus"
'TYPE = 0
'TEMPLATE = "Sub SetCallStatus()"
'TEXT = [[
'*****************************************************************************
' File:         SetCallStatus
' Purpose:      Set Status 
' Copyright:    Quartess, 2002
' *****************************************************************************
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

Dim nGrade As Integer
Dim bCancel As Boolean
Dim sGradeStatement As String
Function Answer_DlgFkt( ControlName$, Action%, SuppValue% )
'Print ControlName$, Action%, SuppValue%

Select Case Action%
 Case 1 ' First time open Dialog
		bCancel = False
		DlgValue "OptionGroup1",nGrade -1 
		If nGrade > 3 Then
 			DlgVisible "Text1", True
  			DlgVisible "Statement", True 
		Else 
 			DlgVisible "Text1", True
  			DlgVisible "Statement", True
		End If
	   DlgVisible "OptionButton7", False
 Case 2 ' something clicked
   Select Case ControlName$
	 Case "OptionButton1"
		  nGrade = 1
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True

	 Case "OptionButton2"
		  nGrade = 2
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True

	 Case "OptionButton3"
		  nGrade = 3
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True

	 Case "OptionButton4"
		  nGrade = 4
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True
	 Case "OptionButton5"
		  nGrade = 5
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True

	 Case "OptionButton6"
		  nGrade = 6
		  DlgVisible "Text1", True
		  DlgVisible "Statement", True

	 Case "OptionButton7"
		  nGrade =7

     Case "OK"
		  		sGradeStatement =	DlgText$("Statement")
     Case "Cancel"
		  		sGradeStatement = ""  
				nGrade =7
				bCancel = True
     End Select	
 End Select
End Function 

Begin Dialog UserDialog ,,234,114,"Benotung der Qualität dieser Meldung",.Answer_DlgFkt
	OKButton 176,8,40,14
	CancelButton 176,26,40,14
	GroupBox 12,4,128,48,"Qualität der Meldung",.GroupBox
	OptionGroup .OptionGroup1
		OptionButton 15,16,24,8,"1",.OptionButton1
		OptionButton 15,28,32,8,"2",.OptionButton2
		OptionButton 15,40,28,8,"3",.OptionButton3
		OptionButton 72,16,24,8,"4",.OptionButton4
		OptionButton 72,29,16,8,"5",.OptionButton5
		OptionButton 72,41,56,8,"6",.OptionButton6
		OptionButton 72,41,56,8,"7",.OptionButton7
	Text 12,56,176,8,"Eine Begründung für eine Benotung schlechter als 3:",.Text1
	TextBox 11,72,217,40,.Statement,1
End Dialog
'----------------------------------------------------------------------------
Sub GradeCall(iGroup As SGroup, sInterval As String)
Dim AnswerIsOK As Boolean
Dim iCallRec As DBRecord
Dim CheckList_dlg As UserDialog
 	nGrade = 7
 	sGradeStatement= ""
	AnswerIsOK = False
	
	If sInterval = "0" Then Exit Sub
	Set iCallRec = iGroup.GetCurrentRecord
	If 	iCallRec.GetValue("grade") <> "" Then Exit Sub 
	If (val( iCallRec.GetValue("pkey") ) Mod val( sInterval)) <> 0 Then  Exit Sub
		Do 
			r1% = Dialog(CheckList_dlg)
		  If nGrade > 3 And  nGrade < 7 And sGradeStatement = "" Then 
				AnswerIsOK = False
				MsgBox " Sie müssen eine Begründung für diese Note eingeben"
		  Else 
				AnswerIsOK	= True
		  End If	
		  If nGrade = 7 Then   AnswerIsOK = False			
		Loop Until AnswerIsOk Or bCancel
	If Not bCancel Then
		iCallRec.SetValue "grade", nGrade
		iCallRec.SetValue "gradestatement", sGradeStatement
	End If
End Sub
'-------------------------------------------------------------------------
Sub SetCallStatus()

Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iSearchNetwork As DBNetwork
Dim iBrowser As DBBrowser
Dim iTaskTable As DBTable
Dim iRec As DBRecord
Dim iGroup As SGroup
Dim nAnswer As Integer
Dim nTAsks As Integer
Dim bRes As Boolean
Dim sInterval As String
    On Error GoTo error_handler

    Set iApp = GetApp()
    Set iNetwork = iApp.ContextFocus.Network()
    Set iGroup = iApp.ContextGroup
	iGroup.BtnClick "callRefresh"
    Set iGroup = iApp.ContextGroup
    ' If there is no backfilled record, get out.
    Set iRec = iGroup.GetCurrentRecord()
    If iRec Is Nothing Then
        iApp.ContextFocus.Message "Keine Meldung ausgewählt"
        Exit Sub
    End If
	Select Case iApp.ContextControlName
	Case "callSetResolved"
		If iGroup.GetValue("callCallstatus") <> "Angenommen" Then
			iApp.UserMsg " Sie können nur angenommene Meldungen fertig melden"
			Exit Sub 
		End If
 		Set iSearchNetwork = iApp.CreateNetwork( "q_taskcount", "q_taskcount" )
   		Set iBrowser = iSearchNetwork.GetBrowser( "taskcountBrowser" )
   		Set iTaskTable = iSearchNetwork.GetTable( "task" )
		sCallID = iRec.GetKeyValue
   		iTaskTable.QBEClear
   		iTaskTable.QBESetValue "calltask", sCallID
		iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
		nTasks = iBrowser.RecordCount
   		Set iTaskTable = Nothing
		Set iBrowser = Nothing
		Set iSearchNetwork = Nothing

		If nTasks > 0 Then
				nAnswer =iApp.UserResponseMsg( "Wollen Sie diese Meldung wirklich fertig melden?",ebQuestion + ebYesNo,"Fertigmeldung"	)
   			If nAnswer = ebYes Then
    	   	 	iGroup.Change
		   		If InStr(iApp.GetUserGroups,"CQ_AGENT")>0 And (iApp.ContextFocus.Name="FWT-SMC Meldungserfassung" Or iApp.ContextFocus.Name="Meldungsbearbeitung") Then
'		   		If InStr(iApp.GetUserGroups,"CQ_AGENT")>0  Then
					iGroup.SetValue "callClosedBySD",1
		   		Else
			   		iGroup.SetValue "callClosedBySD",0
				End If					
   	        	iGroup.SetValue "callCallstatus", "Fertig gemeldet"
	        	iGroup.BtnClick "callUpdate"
	    	End If

		Else
				nAnswer =iApp.UserResponseMsg( "Diese Meldung hat keinen Auftrag." & Basic.Eoln$ & "Wollen Sie einen Auftrag anlegen?",ebCritical + ebYesNoCancel + ebDefaultButton3,"MELDUNG HAT KEINEN AUFTRAG"	)
   	   		If nAnswer = ebCancel Then	Exit Sub
			If nAnswer = ebYes Then
		   		If iGroup.Mode <> MODE_UPDATE And iGroup.Mode <> MODE_NEW Then
	   		  		sCallkey = iGroup.GetValue(iGroup.GUIName("pkey") )
  			  		sPriority =  iGroup.GetValue(iGroup.GUIName("priority"))
					If iApp.Name = "imsys" Or iApp.Name = "testimsys" Then
		 				iApp.ContextFocus.ShowForm "UTtask"
		 				Set iCallGroup = iApp.ContextFocus.GetForm("UTtask").GetGroup( "call" )
		 				iCallGroup.BtnClick "callRefresh"
		  				Set iTaskGroup = iApp.ContextFocus.GetForm("UTtask").GetGroup( "task" )
					Else
		 				iApp.ContextFocus.ShowForm "taskadd"
		 			Set iCallGroup = iApp.ContextFocus.GetForm("taskadd").GetGroup( "call" )
		 			iCallGroup.BtnClick "callRefresh"
		  			Set iTaskGroup = iApp.ContextFocus.GetForm("taskadd").GetGroup( "task" )
					End If
		  			If iTaskGroup.Mode <> MODE_UPDATE And iTaskGroup.Mode <> MODE_NEW Then
		   		 		iTaskGroup.Clear
		   				iTaskGroup.SetForeignValue "taskCall", sCallkey,sCallkey
		   				iTaskGroup.SetValue "taskPriority", sPriority
		  			End If
   	   			End If

			End If
   			If nAnswer = ebNo Then
    	 	   iGroup.change
		   		If InStr(iApp.GetUserGroups,"CQ_AGENT")>0 And (iApp.ContextFocus.Name="FWT-SMC Meldungserfassung" Or iApp.ContextFocus.Name="Meldungsbearbeitung") Then
'		   		If InStr(iApp.GetUserGroups,"CQ_AGENT")>0  Then
		 			iGroup.SetValue "callClosedBySD",1
				Else
					iGroup.SetValue "callClosedBySD",0
	   			End If
   	    	    iGroup.SetValue "callCallstatus", "Fertig gemeldet"
	       		 iGroup.BtnClick "callUpdate"
	    	End If
		End If

	Case "callSetDocumented"
		If iGroup.GetValue("callCallstatus") <> "Fertig gemeldet" Then
			iApp.UserMsg " Sie können nur fertig gemeldete Meldungen dokumentieren"
			Exit Sub 
		End If

    	    iGroup.Change
			sInterval =	GetAppProfileValue( iNetwork, "gradinginterval")
			GradeCall iGroup, sInterval
   	        iGroup.SetValue "callCallstatus", "Dokumentiert"
	        bRes = iGroup.Update
			If bRes Then
				sPkey = iGroup.GetValue("callKey")
				iApp.ContextFocus.Clear
				iGroup.SetValue "callKey", sPkey
				iGroup.BtnClick "callSearch"
			End If
				
	Case "rmnuArray:5"
			If iGroup.GetCurrentRecord.GetValue("grade") = "" Then

    	    	iGroup.Change
				GradeCall iGroup, "1"
   	        	iGroup.GetCurrentRecord.SetValue "personal_vote", "1"
	        	bRes = iGroup.Update
			Else
				iApp.UserMsg "Meldung ist schon benotet."
			End If
	End Select

	Exit Sub

error_handler:
    iApp.UserMsg "SetCallStatus error " & CStr(Err) & ": " & Error$
End Sub




























































































































































































































































































']]
'NAME = "CallDocBackfill"
'TYPE = 0
'TEMPLATE = "Sub CallDocBackfill()"
'TEXT = [[
'*****************************************************************************
' File:         CallDocBackfill
' Purpose:      Gui rule on call backfill, change formulas on IFB
' Copyright:    Quartess, 2002
'*****************************************************************************

'----------------------------------------------------------
Sub CallDocBackfill()
Dim iIFBrowser As SIFBrowser 
Dim iApp As Application
Dim iSearchNetwork As DBNetwork
Dim iForm As SForm
Dim iGroup As SGroup
Dim iBrowser As DBBrowser
Dim iCallRec As DBRecord
Dim sStatus As String
Dim iSubcallTable As DBTable
Dim iAttachmentTable As DBTable
Dim nTotalCallTime As Long
Dim nTotalCoordTime As Long
Dim nTotalCoordTimeSubcall As Long
Dim nTotalTaskTimespent As Long
Dim cTotalTaskAmount As Currency
Dim nTotalTaskTimespentSubcall As Long
Dim nTotalTaskDoc As Long
Dim dCoordTime As Date
Dim nTotalTaskDocSubcall As Long
Dim sTotalTaskAmount As String


    '-------------------------------------------------
    Set iApp = GetApp()
    Set iGroup = iApp.ContextGroup
	If iGroup.Mode <> MODE_FILLED Then Exit Sub
	Set iCallRec = iApp.ContextRecord
    sStatus = iCallRec.GetValue("callstatus" )

	Set iSearchNetwork = iApp.CreateNetwork( "q_taskcount", "q_taskcount" )
 	Set iBrowser = iSearchNetwork.GetBrowser( "callduplicateBrowser" )
   	Set iSubcallTable = iSearchNetwork.GetTable( "callduplicate" )
   	Set iAttachmentTable = iSearchNetwork.GetTable( "attachment" )
' calculate callSumTaskDoc
		sCallID = iCallRec.GetKeyValue

		iSubcallTable.Clear
   		iSubcallTable.QBEClear
   		iSubcallTable.QBESetValue "mastercall_key", sCallID
   		'iSubcallTable.QBESetValue "callstatus", "Dokumentiert|Geschlossen"
		iBrowser.Search "cqlocal" ', QW_DCO_BACK_FILL  Ruleserver kennt das nicht
		nTotalTaskDocSubcall = 0
		nTotalTaskTimespentSubcall = 0
		nTotalCoordTimeSubcall = 0
		sTotalTaskAmount = iCallRec.GetValue( "totaltaskamount"	)
		If 	Len(sTotalTaskAmount) > 3 Then
			cTotalTaskAmount  =cCur(left$(sTotalTaskAmount,Len(sTotalTaskAmount)-3))
		Else
			cTotalTaskAmount = 0
		End If 
		For i = 1 To iBrowser.RecordCount
		   nTotalTaskDocSubcall = nTotalTaskDocSubcall + iApp.IntervalToSeconds(iBrowser.GetRecord(i-1).GetValue("totaltaskdoc"))	
		   nTotalTaskTimespentSubcall = nTotalTaskTimespentSubcall + iApp.IntervalToSeconds(iBrowser.GetRecord(i-1).GetValue("totaltasktimespent"))	
		   nTotalCoordTimeSubcall = nTotalCoordTimeSubcall + iApp.IntervalToSeconds(iBrowser.GetRecord(i-1).GetValue("coordinationtime"))	
		   sTotalTaskAmount = iBrowser.GetRecord(i-1).GetValue("totaltaskamount")
		   cTotalTaskAmount = cTotalTaskAmount  + cCur(left$(sTotalTaskAmount,Len(sTotalTaskAmount)-3))
		Next i
		nTotalTaskDoc = iApp.IntervalToSeconds(iCallRec.GetValue("totaltaskdoc"))
		iGroup.SetValue "callSumTaskDoc",Format( iApp.SecondsToInterval(nTotalTaskDoc+nTotalTaskDocSubcall),"h:nn"), True
		iGroup.SetValue "callTotaltaskdoc",Format( iApp.SecondsToInterval(nTotalTaskDoc),"h:nn"), True

' calculate callSumTaskTimespent
		nTotalTaskTimespent= iApp.IntervalToSeconds(iCallRec.GetValue("totaltasktimespent"))
		iGroup.SetValue "callSumTaskTimespent", Format(iApp.SecondsToInterval(nTotalTaskTimespent+nTotalTaskTimespentSubcall), "h:nn"), True
		iGroup.SetValue "callTotaltasktimespent", Format(iApp.SecondsToInterval(nTotalTaskTimespent), "h:nn"), True

' calculate callSumCoordtime

		nTotalCoordTime= val(iCallRec.GetValue("coordinationtime_h")) *3600 + val(iCallRec.GetValue("coordinationtime_m")) * 60
		iGroup.SetValue "callSumCoordtime",Format( iApp.SecondsToInterval(nTotalCoordTime+nTotalCoordTimeSubcall),"h:nn") , True

' Calculate TotalCallTime
		nTotalCallTime = iApp.IntervalToSeconds(iCallRec.GetValue("sd_time")) + _
						 nTotalCoordTime+nTotalCoordTimeSubcall + _
						 nTotalTaskTimespent+nTotalTaskTimespentSubcall +_
						 nTotalTaskDoc+nTotalTaskDocSubcall

		iGroup.SetValue "callTotalCalltime", Format(iApp.SecondsToInterval(nTotalCallTime),"h:nn"), True

		iGroup.SetValue "callSl", Format(iCallRec.GetValue("sl"),"h:nn"), True
		iGroup.SetValue "callKsl", Format(iCallRec.GetValue("ksl"),"h:nn"), True
' Calculate totalamount
			iGroup.SetValue "callSumTaskAmount", Format(cTotalTaskAmount,"0.00") & " EUR", True
' Calculate Attachments
	   iAttachmentTable.QBEClear
	   iAttachmentTable.QBESetValue "callattachment", sCallID
	   iAttachmentTable.search
	   If iAttachmentTable.RecordCount > 0 Then				
			iGroup.SetValue "hasattachment", "1", True
		Else 
			iGroup.SetValue "hasattachment", "0", True
		End If

	If iApp.ContextForm.Name="callMngrDocument" Then
   		Set iIFBrowser = iGroup.GetIFBrowser( "taskIFBrowser" )
 		nIFBRows = iIFBrowser.Rows
  		ntotalprice = 0
  		For i = 1 To nIFBrows
  			If iIFBrowser.RowState(i) = ROW_FILLED Then
   				sValue =Format(iIFBrowser.GetCellValue( i, "TimeDoc"),"hh:nn")
  				iIFBrowser.SetCellValue i, "TimeDoc", sValue
 				sValue =Format(iIFBrowser.GetCellValue( i, "Timespent"),"hh:nn")
   				iIFBrowser.SetCellValue i, "Timespent", sValue
			End If
   		Next  
   		Set iIFBrowser = iGroup.GetIFBrowser( "callduplicateIFBrowser" )
   		nIFBRows = iIFBrowser.Rows
   		ntotalprice = 0
   		For i = 1 To nIFBrows
   			If iIFBrowser.RowState(i) = ROW_FILLED Then
	 			sValue =Format(iIFBrowser.GetCellValue( i, "browserCoordtime"),"hh:nn")
	   			iIFBrowser.SetCellValue i, "browserCoordtime", sValue
	   			sValue =Format(iIFBrowser.GetCellValue( i, "browserTotaltaskdoc"),"hh:nn")
				iIFBrowser.SetCellValue i, "browserTotaltaskdoc", sValue
				sValue =Format(iIFBrowser.GetCellValue( i, "browserTotaltasktimespent"),"hh:nn")
				iIFBrowser.SetCellValue i, "browserTotaltasktimespent", sValue
   			End If
   		Next  
	End If
		Set iCallduplicateTable = Nothing
		Set iBrowser = Nothing
		Set iSearchNetwork = Nothing
		Set iiAttachmentTable = Nothing
 End Sub



























































































































































































































































































']]
'NAME = "AfterCustomerSearch"
'TYPE = 0
'TEMPLATE = "Sub AfterCustomerSearch()"
'TEXT = [[
'*****************************************************************************
'Script:	AfterCustomerSearch
'Purpose:	This QScript runs after the Agent search a customer.
'			Simulate a CTI timestamp datecallconnected.
'Copyright:	Quartess , 2002
'*****************************************************************************
'---------------------------------------------------------------------------
' Global Constants, Types, and Variables for this QScript
'---------------------------------------------------------------------------
 Public dDatecallconnected As Date
'---------------------------------------------------------------------------
' QScript API Declarations
'---------------------------------------------------------------------------

'---------------------------------------------------------------------------
' Internal Subs & Functions
'---------------------------------------------------------------------------

'---------------------------------------------------------------------------
' Main
'---------------------------------------------------------------------------
Sub AfterCustomerSearch()
Dim iApp As Application

    On Error GoTo ERROR_HANDLER
    '-------------------------------------------------
	Set iApp = GetApp

	dDatecallconnected= iApp.ContextNetwork.GetTable("appprofile").DBNow
    Exit Sub

ERROR_HANDLER:
    iApp.UserMsg "AfterCustomerSearch error " & CStr(Err) & ": " & Error$, ebCritical + ebSystemModal
End Sub 


















































































































































































































































































']]
'NAME = "FirstLevelCloseCall"
'TYPE = 0
'TEMPLATE = "Sub FirstLevelCloseCall()"
'TEXT = [[
' Um eine Rückmeldung bei Firstlevel schließen an den Melder zu unterdrücken
' benötigt man eine Variable
Public bFirstLevelCloseCall As Boolean

Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String
Sub FirstLevelCloseCall()
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iGroup As SGroup
Dim iCallTable As DBTable
Dim iCallRec As DBRecord
Dim iWorkgroupTable As DBTable
Dim iOwnerRec As DBRecord
Dim sOwner As String
Dim sOwnerKey As String
Dim sToday As String
Dim sAnswer As String
Dim sStatus As String
    On Error GoTo acceptcall_error_handler

    Set iApp = GetApp()		 
    Set iNetwork = iApp.ContextFocus.Network()
    Set iGroup = iApp.ContextGroup				   
    Set iCallTable = iApp.ContextTable

    ' If there is no backfilled record, get out.
    Set iCallRec = iGroup.GetCurrentRecord()
    If iCallRec Is Nothing Then
        iApp.ContextFocus.Message "Keine Meldung ausgewählt"
        Exit Sub
    End If
	sStatus =  iGroup.GetValue("callCallstatus")
	If InStr("Durchgestellt|AK zugewiesen",sStatus) = 0 Then
	
 		Select Case iApp.ContextControlName
   			Case "callClosedforNMAK"		' jetzt Storno
				If InStr("Durchgestellt|AK zugewiesen|Angenommen",sStatus) = 0 Then
					iApp.UserMsg "In diesem Status darf die Meldung nicht storniert werden.",ebCritical
					Exit Sub
				End If
			Case "callMeldungSchliessen"
					iApp.UserMsg "In diesem Status darf die Meldung nicht fertig gemeldet werden mit '1st level schließen'.",ebCritical
					Exit Sub
	  		End Select
	End If

	Select Case iApp.ContextControlName
		Case "callClosedforNMAK"
	   		If iGroup.Mode <> MODE_UPDATE And iGroup.Mode <> MODE_NEW And iGroup.Mode <> MODE_FILLED Then
				Exit Sub
			End If
				nAnswer =iApp.UserResponseMsg( "Wollen Sie diese Meldung wirklich stornieren?",ebQuestion + ebYesNo,"Storno"	)
   			If nAnswer = ebNo or nAnswer = ebCancel Then
				Exit Sub
			End If
			If iGroup.Mode = MODE_FILLED Then
				iGroup.Change
			End If

			If iCallRec.GetValue("dateassigned") ="" Then
  				sGroupName =iGroup.GUIName("dateassigned")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now",True
  				End If
					iCallRec.SetValue "dateassigned", "now"
			End If
			If iCallRec.GetValue("dateowned") ="" Then
  				sGroupName =iGroup.GUIName("dateowned")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now",True
  				End If

	   	   		iCallRec.SetValue "dateowned", "now"
			End If
			If iCallRec.GetValue("dateresolved") ="" Then
  				sGroupName =iGroup.GUIName("dateresolved")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now",True
  				End If

				iCallRec.SetValue "dateresolved", "now"
			End If
			If iCallRec.GetValue("datedocumented") ="" Then
  				sGroupName =iGroup.GUIName("datedocumented")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now",True
  				End If

	        	iCallRec.SetValue "datedocumented", "now"
			End If
			iGroup.SetValue "callCallstatus","Verworfen"
			iCallRec.SetValue "callstatus", "Verworfen"
			iCallRec.SetValue "closedby_sd", 1
			iCallRec.SetValue "coordinationtime", "00:00:00"
			If Not iGroup.Update Then 
				iGroup.SetValue "callCallstatus", sStatus
			End If

		Case "callMeldungSchliessen"
			sAnswer = InputBox$("Wie groß war der Koordinationsaufwand in Minuten?"," Koordinationsaufwand","0")
			If sAnswer = "" Then  Exit Sub
	   		If iGroup.Mode <> MODE_UPDATE And iGroup.Mode <> MODE_NEW And iGroup.Mode <> MODE_FILLED Then
				Exit Sub
			End If
			If iGroup.Mode = MODE_FILLED Then
				iGroup.Change
			End If
			sPkey = GetAppProfileValue(iNetwork, "callworkgroup_key")
			If sPkey = "" Or sPkey = "NULL" Then
	 			iApp.UserMsg "Es fehlt die Information über den SD AK",ebCritical
	 			Exit Sub
    		End If
			If InStr(iApp.GetUserGroups,"CQ_WARTE") =0 Then
				sName = iNetWork.GetTable("callworkgroup").GetValueWhere("name","pkey",sPkey)
        		iGroup.SetForeignValue "callWorkgroup", sName, sPkey  
			Else
				If iCallRec.GetValue("workgroupcall") = "NULL" Or iCallRec.GetValue("workgroupcall") = "" Then
			  		sName = iNetWork.GetTable("callworkgroup").GetValueWhere("name","pkey",sPkey)
        	   		iGroup.SetForeignValue "callWorkgroup", sName, sPkey  
   				End If
			End If
			iGroup.GetCurrentRecord.SetValue "coordinationtime", iApp.SecondsToInterval(val(sAnswer)*60)
			bFirstLevelCloseCall = True
        	iGroup.SetValue "callCallstatus", "Dokumentiert"
			If iCallRec.GetValue("dateassigned") ="" Then
  				sGroupName =iGroup.GUIName("dateassigned")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now"
  				End If
					iCallRec.SetValue "dateassigned", "now"
			End If
			If iCallRec.GetValue("dateowned") ="" Then
  				sGroupName =iGroup.GUIName("dateowned")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now"
  				End If

	   	   		iCallRec.SetValue "dateowned", "now"
			End If
			If iCallRec.GetValue("dateresolved") ="" Then
  				sGroupName =iGroup.GUIName("dateresolved")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now"
  				End If

				iCallRec.SetValue "dateresolved", "now"
			End If
			If iCallRec.GetValue("datedocumented") ="" Then
  				sGroupName =iGroup.GUIName("datedocumented")
 				If sGroupName <> "" Then 
					iGroup.SetValue sGroupName, "now"
  				End If

	        	iCallRec.SetValue "datedocumented", "now"
			End If

        	 If Not iGroup.Update Then iGroup.SetValue "callCallstatus", sStatus
		Case Else
			Exit Sub
	End Select



    Exit Sub

acceptcall_error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "FirstlevelCloseCall error " & CStr(Err) & ": " & Error$
 End Sub














































































































































































































































































']]
'NAME = "TaskAddBackfill"
'TYPE = 0
'TEMPLATE = "Sub TaskAddBackfill()"
'TEXT = [[
'*****************************************************************************
' File:         TaskAddBackfill
' Purpose:      Gui rule on call backfill in TAskAdd form to show the ext_system
' Copyright:    Tarragon, 2002
'*****************************************************************************

Sub TaskAddBackfill()
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iForm As SForm
Dim iGroup As SGroup
Dim sExtSystem_key As String
Dim sExtSystemName As String
Dim sObject_key As String


    '-------------------------------------------------
    Set iApp = GetApp()
	Set iNetwork = iApp.ContextNetwork
    Set iGroup = iApp.ContextGroup
	Set iCallRec = iApp.ContextRecord
	sObject_key	=iCallRec.GetValue("object_key")
	sExtSystemName = ""
	If sObject_key <> "" And sObject_key <> "NULL"  Then
		sExtSystem_key	= iNetwork.GetTable("object").GetValueWhere("ext_system_key","pkey", sObject_key)
		If sExtSystem_key <> "" And sExtSystem_key <> "NULL"  Then
			sExtSystemName	= iNetwork.GetTable("ext_system").GetValueWhere("name","pkey", sExtSystem_key)
		End If
	End If
	iGroup.SetReadOnly "callExtSystem"
	iGroup.SetValue "callExtSystem", sExtSystemName, True	 
End Sub


















































































































































































































']]
'NAME = "CallMasterDetail"
'TYPE = 0
'TEMPLATE = "Sub CallMasterDetail()"
'TEXT = [[
Public bCallMasterDetail As Boolean

Sub CallMasterDetail()
Dim iApp As Application
Dim iGroup As SGroup
Dim iTargetGroup As SGroup
Dim iForm As SForm
Dim sKey As String
Dim sName As String	

	On Error GoTo ERROR_HANDLER
    '----------------------------------
    Set iApp = GetApp()
	Set iGroup = iApp.ContextGroup
	If iGroup.Mode <> MODE_FILLED And ( iGroup.GetValue("callMastercall") = "" Or iGroup.GetValue("callMastercall") = "NULL" ) Then
	   Exit Sub
	End If
	sKey = iGroup.GetValue("callMastercall")
		iApp.ContextFocus.Clear
		iGroup.SetValue "callKey", sKey
		bCallMasterDetail = True
		iGroup.BtnClick "callSearch"
	 Exit Sub	
Error_handler:
    iApp.UserMsg "CallMasterDetail error " & CStr(Err) & ": " & Error$

Exit_Sub:
End Sub
















































































































































































']]
'NAME = "BeforeCallSerarch"
'TYPE = 0
'TEMPLATE = "Function BeforeCallSearch() As Boolean"
'TEXT = [[

'*****************************************************************************
' File:         BeforeCallSearch
' Purpose:      Constraint Search for calls assigned to my workgroups
' Copyright:    Quintus Corporation, 1996
' *****************************************************************************

Public bCallMasterDetail As Boolean

Function BeforeCallSearch() As Boolean

Dim iApp As Application
Dim iTable As DBTable
Dim iForm As SForm
Dim iNetwork As DBNetwork
Dim sDummy As String

    On Error GoTo Error_handler
    Set iApp = GetApp()
	Set iForm = iApp.ContextForm

	Set iNetwork = iApp.ContextNetwork

	Set iTable = iNetwork.GetTable( "groupmember" )
	iTable.Clear
	If Not bCallMasterDetail Then
  		sDummy = iApp.GetUserGroups
  		If (InStr( sDummy, "CQ_PM" ) > 0 ) Or _
  			(InStr( sDummy, "CQ_ADMIN" ) > 0 ) Or _
   			(InStr( sDummy, "CQ_AGENT" ) > 0 ) Or _
			(InStr( sDummy, "CQ_SDADMIN" ) > 0 )Then
				sSearchStr = ""
   		Else 
	   	sSearchStr = "=" & iApp.CurrentUserKey
   		End If
	   iTable.QBESetValue "employeegroup", sSearchStr
	End If
	bCallMasterDetail = False
 
	Select Case iForm.Name
		Case "callMngrDocument" ,"callMngrCaretaker","UTcallMngrDocument","UTcallEntryCaretaker"
			sRelationSet ="r_call"
		Case "callEntryCaretakerAK"
			sRelationSet ="r_call_entry"
		Case "taskadd", "taskbill",	"taskdocumentation"	,"UTtask","UTtaskdocumentation", "taskEdvin"
			sRelationSet ="r_task"
		Case Else
			sRelationSet = "cq_default"
	End Select
    iApp.ContextFocus.ApplyCurrentConstraints sRelationSet
    iApp.ContextBrowser.Search sRelationSet , 2	 ' QW_DCO_FILL_BOTH

    ' Clear the QBE Data for iTable and ContextTable before exiting
    iTable.QBEClear

    ' Return False to prevent standard search
    BeforeCallSearch = False
    Exit Function

Error_handler:
'!!: iApp.UserMsg
    iApp.UserMsg "BeforeCallSearch error " & CStr(Err) & ": " & Error$

    ' Clear the QBE Data for iTable and ContextTable before exiting
    If Not iTable Is Nothing Then
        iTable.QBEClear
    End If

    BeforeCallSearch = False
End Function
























































































































































']]
'NAME = "PrintFAX"
'TYPE = 0
'TEMPLATE = "Sub PrintFAX()"
'TEXT = [[
'*****************************************************************************
' Script:       PrintFax
' Purpose:      Preparing Fax
' Copyright:    Tarragon, 2003 MDo
'*****************************************************************************
Declare Function SaveMessage( iNetwork As DBNetwork,  sTo As String, sSubject As String, sMsg As String, sStylesheet As String, sTable As String, sKey As String) As Boolean

Declare Function ConvertFormular(iApp As Application,iNetwork As DBNetwork, sTemplateFile As String, bHTML As Boolean )  As String
Declare Function GetAppProfileValue(iNetwork As DBNetwork, _
									sFieldname As String) As String

'-------------------------------------------------------------------------------------
Dim iQNetwork       As  DBNetwork
Dim iQTable         As  DBTable
Dim iQRecord        As  DBRecord
Dim iNewQRec        As  DBRecord
Dim iDefaultTable   As  DBTable
Dim iDefaultNetwork As  DBNetwork
Dim iDefaultRecord  As  DBRecord
Dim sTemplateList() As String
Dim nTemplateNo     As Integer
Dim sRecipient As String
Dim sTemplatePkey() As String
Dim bCancel As Boolean
Dim sTablename As String


Function Dlg_Fkt( ControlName$, Action%, SuppValue% )

Select Case Action%
	Case 1 ' First time open Dialog
		nTemplateNo=0

	Case 2 ' something clicked
		Select Case ControlName$
			Case "OK"
			  bCancel = False
			Case "Cancel"
				Dlg_Fkt=0
			  bCancel = True
			Case "TemplateListBox"
				nTemplateNo = SuppValue%
		End Select
End Select
End Function
'-------------------------------------------------------------------
Sub PrintFAX()
Dim iApp As Application
Dim nRecs,i,r1 As Integer
ReDim sTemplateList(0)
ReDim sTemplatePkey(0)
ReDim sMethodDropListBox(3)
ReDim sRecipientDropListBox(2)
Dim iXMLTable As DBTable
Dim bStatus As Boolean
Dim sMsg As String 
Dim sStylesheet As String
Dim sXML_key As String
Dim sDirectory As String
Dim sFileName As String
Dim nChanel As Integer

On Error GoTo Notification_error

Begin Dialog GetTemplateDialog ,,244,88,"Drucken",.Dlg_Fkt
	OKButton 198,24,40,14
	CancelButton 198,44,40,14
	ListBox 4,25,172,56,sTemplateList,.TemplateListBox
	Text 4,8,168,8,"folgendes Template drucken",.Text1
End Dialog

	Set iApp=GetApp()
	Set iDefaultNetwork = iApp.ContextNetwork
	Set iDefaultRecord = iApp.ContextGroup.GetCurrentRecord
	If Not iDefaultRecord Is Nothing Then
	   	Set iDefaultTable = iDefaultRecord.GetTable
   	Else
   	   	Set iDefaultTable = iDefaultNetwork.GetTable( iApp.ContextGroup.TableName() )
	End If
	Set iQTable = iDefaultNetwork.GetTable( "doc_template" )
	iQTable.Clear
	iQTable.QBEClear
	If right$(iDefaultTable.Name,4) ="call" Then iQTable.SetWhere "doc_template.use_in <> 1 and doc_template.rtftext >0"
	If right$(iDefaultTable.Name,4) ="task" Then iQTable.SetWhere "doc_template.use_in <> 0 and doc_template.rtftext >0"
	iQTable.Search
	iQTable.SetWhere ""
	nRecs = iQTable.RecordCount
	If nRecs > 0 Then
		nRecs = nRecs - 1
		ReDim sTemplateList( nRecs )
		ReDim sTemplatePkey( nRecs )
		For i=0 To nRecs 
			Set iQRecord = iQTable.GetRecord( i )
			sTemplateList( i ) = iQRecord.GetValue( "name" )
			sTemplatePkey( i ) = iQRecord.GetValue("pkey")
		Next i
		Set iQRecord = Nothing
	Else
		iApp.UserMsg "Es stehen keine Vorlagen zur Verfügung"
		Exit Sub
	End If
	bCancel = False
	Dim GetTemplate As GetTemplateDialog
	Do
		r1% = Dialog( GetTemplate )
	Loop Until r1% <> 3
	If bCancel Then GoTo  Exit_Sub
		 sDoc_key =	iQTable.GetRecord(nTemplateNo).GetValue("pkey")
		sMsg = iQTable.GetRecord(nTemplateNo).GetValue("rtftext")
		sMsg = ConvertFormular(iApp,iDefaultNetwork, sMsg,false)
			If sDirectory = "" Then
				sDirectory = Environ( "TMP" )
			End If
			If sDirectory = "" Then
				sDirectory = "C:"
			End If
			If Right$( sDirectory, 1 ) <> "\" Then
				sDirectory = sDirectory & "\"
			End If
			On Error Resume Next
			kill sDirectory & "doc*.RTF"
			On Error GoTo Notification_error

			sFileName = sDirectory & "doc" & Format(Now(), "yyyymmdd-hhnnss") & ".RTF"
			nChanel = FreeFile()	' Write
			Open sFilename For Output  As nChanel
					Print # nChanel, sMsg 
			Close nChanel
	If UCase$(Right$( sFileName,4))= ".XML"	Then
        iApp.SetURL sFileName
        iApp.ShowHTMLBrowser
	Else
		nPID = shell( Environ$( "COMSPEC" ) & " /c """ & sFileName & """", ebHide )
	End If
	Exit Sub
 
Exit_Sub:
	Set iQNetwork = Nothing
Exit Sub

Notification_error:
	If Not( iQNetwork Is Nothing ) Then
		Set iQNetwork = Nothing
	End If
	iApp.UserMsg "TroubleTicket error " & CStr( Err ) & ": " & Error$
End Sub
























































































































































































































































































































']]
'NAME = "Gruppenruf"
'TYPE = 0
'TEMPLATE = "Sub Gruppenruf()"
'TEXT = [[
'*****************************************************************************
'Script:       Gruppenruf
'Purpose:      GUI script to collect info and create a task after a Gruppenruf
'Type:	       GUI Rule
'Copyright:    Tarragon MDo, 2003
'*****************************************************************************
Const nCancel = 0
Const nOK = 1
Dim sWorkgroupPhone As String
Dim sAKname As String

Dim nResult As Integer 

Function MainDlgFkt(id$, action%, suppval%)
    Select Case action
		Case 1 ' Start First Time
		    DlgText "Name", ""
		    DlgText "Phone", sWorkgroupPhone
			
        Case 2
			nResult = -1
            If id$ = "Abgewiesen"  Then
                nResult = nCancel
            Else
                sAKname = Dlgtext$("Name")
				If id$ = "Angenommen" And sAKname <> "" Then
                	nResult = nOK
				End If
            End If
    End Select
End Function

Sub Gruppenruf()
Dim iApp As Application
Dim iAKFocus As SFocus
Dim iForm As SForm
Dim iCallRec As DBRecord
Dim iCallGroup As SGroup
Dim iTaskGroup As SGroup
Dim nGroupMode As Integer
Dim iNetwork As DBNetwork
Dim iWorkgroupTable As DBTable
Dim sIsConference As String
Dim sWkgpKey As String
Dim nAnswer As Integer
Dim sCallKey As String
Dim sObjectName As String


    On Error GoTo Error_handler
    '-------------------------------------------------
    Set iApp = GetApp
    Set iCallRec = iApp.ContextRecord

	Set iCallGroup = iApp.ContextGroup()

	sWkgpKey = iCallGroup.GetForeignKey("callWorkgroup")
   	Set iWorkgroupTable = iApp.ContextNetwork.GetTable("callworkgroup")
	
	sIsConference = iWorkgroupTable.GetValueWhere("groupconferencecall", "pkey", sWkgpKey)
	If sIsConference <> "Ja" Then
		iApp.UserMsg "Dieser AK wünscht keinen Gruppenruf"
		Exit Sub
	End If
	If iCallGroup.GetValue( "callCallstatus") <> "AK zugewiesen"  Then
		iApp.UserMsg "Nur für zugewiesene Meldungen gilt Gruppenruf"
		Exit Sub
	End If
 
    sWorkgroupPhone = iWorkgroupTable.GetValueWhere("phone", "pkey", sWkgpKey)
	
Begin Dialog UserDialog ,,246,78,"Gruppenruf",.MainDlgFkt
	Text 4,6,60,8,"Gruppenruf unter: ",.Text1
	Text 72,5,72,8,"123456789",.Phone,,10,ebBold
	Text 4,20,64,8,"Angenommen von: ",.Text2
	TextBox 73,19,167,12,.Name
	PushButton 49,52,52,14,"Angenommen",.Angenommen
	PushButton 140,52,52,14,"Abgewiesen",.Abgewiesen
End Dialog
	
Dim d As UserDialog
	Do
       Dialog d
	Loop Until nResult = nOK Or nResult = nCancel

	If nResult = nCancel Then Exit Sub

	iCallGroup.Change
	iCallGroup.SetValue "callForwardbyphone" ,"1"
    iCallGroup.SetValue "callCallstatus", "Angenommen"
	iCallGroup.GetCurrentRecord.SetLTValue "problemtext" ,"###### " & iApp.DBUser & ": " & Now() & Basic.Eoln$ & "  Gruppenruf wurde angenommen von: " & sAKname
	iCallGroup.Update
	nAnswer = iApp.UserResponseMsg( " Möchten Sie für  " & sAKname & " einen Auftrag anlegen? ", ebYesNo)
	
	If nAnswer = ebNo Then Exit Sub
	sCallKey = iCallGroup.GetValue("callKey")
	sObjectName =  iCallGroup.GetValue("callObject")

	Set iAKFocus = iApp.GetClearFocus("FWT-SMC Meldungsbearbeitung")
	iAKFocus.Show
	iAKFocus.ShowForm "taskadd"
	Set iCallGroup = iAKFocus.GetForm("taskadd").GetGroup("Call")
	iCallGroup.SetValue "callKey", sCallKey
	nAnswer = iCallGroup.Search( "r_call",2)
	Set iTaskGroup = iAKFocus.GetForm("taskadd").GetGroup("task")
	iTaskGroup.BtnClick "taskNew"
	iTaskGroup.SetValue "taskSummary",  sObjectName
    Exit Sub  

Error_handler:
    iApp.UserMsg "Gruppenruf error " & CStr(Err) & ": " & Error$
 End Sub

























































']]
'NAME = "CustomerCall"
'TYPE = 0
'TEMPLATE = "Sub CustomerCall()"
'TEXT = [[
'*****************************************************************************
'Script:       RuleServer: CustomerCall
'Author:       Mike Döring
'Purpose:      Scan the custcall table where possible customer calls avaliable
'Copyright:    Quartess, 2004
'*****************************************************************************
Declare Function SetAppProfileValue(iNetwork As DBNetwork, sFieldname As String, sValue As String) As Boolean

' global DCO data declaration
Dim iApp As Application
Dim iNetwork As DBNetwork
Dim iCallTbl As DBTable
Dim iCustCallTbl As DBTable
Dim iCallRec As DBRecord
Dim iCustCallRec As DBRecord
Public bCalledFromRuleServer As Boolean ' Check ist Script called from Client or Ruleserver				
Dim sLogFile As String
Dim sLockFile As String
Dim nLogLevel As Integer

Dim sCallAgent As String 
Dim sDefaultAK As String
Dim sDefaultGewerk As String
Dim sDefaultProzess As String
' administrator's info
Dim bAdminEmailOnErrors As Boolean
Dim sAdminEmailSubject As String
Dim sAdminEmailAddr As String
Dim sAdminFullName As String
'-------------------------------------------------------------------------

' KONSTANTEN
Const IniFile = "RuleServer.ini"
Const LOGFILE = "D:\Quintus\QeS55\logs\CustomerCall.log"
Const INISection = "CustomerCall"
'-------------------------------------------------------------------------



Sub WriteLog( nLevel As Integer, sMessage As String )
Dim sDate As String
Dim nChanel As Integer

	On Error Resume Next
	If ( nLevel > nLogLevel ) Then Exit Sub
	If ( Len( sLogfile ) = 0 ) Then Exit Sub 
	sDate = CStr( Date() + Time() )
	nChanel = FreeFile()
	Open sLogFile For Append Lock Write As nChanel
	Print # nChanel, "[" & sDate & "] - " & sMessage
	Close nChanel
End Sub

'-------------------------------------------------------------------------


Sub SendAdminEmail( )
Dim i As Integer
	On Error Resume Next ' just to be sure no errors can stop me now
	sBody = "Suchen Sie bitte in Administration/YAN nach fehlerhaften Kundenmeldungen" & Basic.Eoln$ 
	sBody = sBody & Basic.Eoln$ & " vgl. auch " & sLogFile	
	WriteLog 3, "Email an Administrator: " & sAdminEmailAddr & ": " &  sAdminEmailSubject	
	bRes =iApp.SendMail( sAdminEmailAddr, sAdminEmailSubject,, sBody)
	If bRes = True Then
		WriteLog 3, "gesendet."	
	Else 
		WriteLog 3, "nicht gesendet."
	End If	
End Sub

'-------------------------------------------------------------------------


Sub LogError( sOrigin As String, nNumber As Integer )
Dim sMsg As String
	On Error GoTo logerror_error_handler
	If nNumber > 0 Then 
		sMsg = " Error " & CStr( nNumber ) & ": " & Error$( nNumber )
	Else
	  sMsg = ""
	End If
	WriteLog 0, sOrigin & sMsg
logerror_error_handler:
	Exit Sub
End Sub

'----------------------------------------------------------------
'************************************************************************-
'Function CreateLink(sForeignFieldname As String, sTableName As String, sKeyname As String, sKeyValue As String) As Boolean
'************************************************************************-
Function CreateLink(sForeignFieldname As String, sTableName As String, sKeyname As String, sKeyValue As String) As Boolean
Dim iTable As DBTable
On Error GoTo error_handler
	Set iTable = iNetwork.GetTable(sTableName)
	iTable.Clear
	iTable.QBEClear
'	iTable.QBESetValue sKeyname, "=" & sKeyVAlue
	iTable.QBESetValue sKeyname,  sKeyValue
	iTable.Search
	If iTable.RecordCount = 1 Then
		iCallRec.SetValue sForeignFieldname,	sKeyValue
		CreateLink = True
	Else
		CreateLink = False
	End If
	Set iTable = Nothing
	Exit Function
error_handler:
	On Error Resume Next
	Set iTable = Nothing
	LogError "CreateLink zu " & sTableName & " mit Key : " & sKeyVAlue & " fehlgeschlagen", Err.Number
	CreateLink = False
End Function

'************************************************************************-
'Function CreateCall() As Boolean
'************************************************************************-
Function CreateCall(sCustCallkey As String) As Boolean

On Error GoTo Error_handler
	iCustCallTbl.QBESetValue "pkey", sCustCallkey
	iCustCallTbl.Search
	If 	iCustCallTbl.RecordCount <> 1 Then
		LogError "CustCall mit Key " & sCustCallkey & " nicht gefunden"	,0
		CreateCall = False
		Exit Function
	End If

	 Set iCustCallRec = iCustCallTbl.GetRecord(0)
	
	 Set iCallRec = iCallTbl.AddRecord
	 If Not (CreateLink("process_key" , "process", "pkey", sDefaultProzess )) Then
		  		sErrorMsg = "ERROR - Erstellen der DB Links für Tätigkeit"
				GoTo  Error_handler
     End If
	 If Not (CreateLink("workgroupcall" , "callworkgroup", "pkey", sDefaultAK )) Then	
		  		sErrorMsg = "ERROR - Erstellen der DB Links für  AK ist fehlgeschlagen"
				GoTo  Error_handler
	End If
	 If Not (CreateLink("employeecall" , "customerint", "pkey", iCustCallRec.GetValue("employee_key") ) And	_
	         CreateLink("affectedperson_key" , "affectedperson", "pkey", iCustCallRec.GetValue("employee_key") )) Then	
		  		sErrorMsg = "ERROR - Erstellen der DB Links für betroffene Person oder Melder ist fehlgeschlagen"
				GoTo  Error_handler
	End If
	If Not (CreateLink("agentcall" , "agent", "pkey", sCallAgent )) Then	
		  		sErrorMsg = "ERROR - Erstellen der DB Links für Agent ist fehlgeschlagen"
				GoTo  Error_handler
	End If
	If Not (CreateLink("categorycall" , "category", "pkey", sDefaultGewerk )) Then	
		  		sErrorMsg = "ERROR - Erstellen der DB Links für Gewerk ist fehlgeschlagen"
				GoTo  Error_handler
	End If
	sErrorMsg = "ERROR - Meldungsdaten speichern fehlgeschlagen"
	iCallRec.SetValue "datereported", iCustCallRec.GetValue("datecreated")
	iCallRec.SetValue "problem", "Meldung von " & iNetwork.GetTable("customerint").GetRecord(0).GetValue("fullname")
	iCallRec.SetValue "custtext", "Der Auftrag wurde zur Bearbeitung weitergeleitet"
	iCallRec.SetValue "datecallconnected", iCustCallRec.GetValue("datecreated")
	iCallRec.SetLTValue "problemtext", iCustCallRec.GetValue("description")
	rem iCallRec.SetValue "pkey", iCustCallRec.GetValue("pkey")
	sErrorMsg = "ERROR - Meldung speichern fehlgeschlagen"
	iCallTbl.Commit
    WriteLog 3, "Meldung mit Nummer " & iCallRec.GetValue("pkey") & " angelegt"
	sErrorMsg = "ERROR - CustCall löschen fehlgeschlagen"
    iCustCallRec.Delete
	iCustCallTbl.Commit
CreateCall = True
Exit Function
Error_handler:
   iCustCallRec.SetValue "error","Ja"
   iCustCallTbl.commit		
   LogError	 "CreateCall " + sErrorMsg , Err.Number
CreateCall = False

End Function
'-------------------------------------------------------------------------
Function GetIniInfo( sSection, sItem, sDefault ) As String
Dim sRet As String
	On Error GoTo getiniinfo_error_handler
	sRet = ReadIni$( sSection, sItem, IniFile )
	If sRet <> "" Then
		GetIniInfo = sRet
	Else
		GetIniInfo = sDefault
	End If
	Exit Function
getiniinfo_error_handler:
	GetIniInfo = sDefault
End Function

'-------------------------------------------------------------------------

Function CBool( sStr As String ) As Boolean
	On Error GoTo cbool_error_handler
	If UCase$( sStr ) = "TRUE" _
	Or UCase$( sStr ) = "WAHR" Then
		CBool = True
		Exit Function
	End If
cbool_error_handler:
	CBool = False
End Function

'-------------------------------------------------------------------------
Sub Initialize
	Set iApp = GetApp ' LogError uses SendEmail, SendEmail uses iApp

	nLogLevel = CInt( GetIniInfo( INISection, "LogLevel","3" ) )
	sLogFile = GetIniInfo( INISection, "LogFile", LOGFILE)
	WriteLog 3, "PROZEDUR CustomerCall"
	WriteLog 3, "Script Started"
	sAdminFullName = GetIniInfo( INISection, "sAdminFullName", "Stephan Thümmler" )
	sAdminEmailAddr = GetIniInfo( INISection, "AdminEmailAddr", "stephan.thuemmler@daimlerchrysler.com" )
	bAdminEmailOnErrors = CBool( GetIniInfo( INISection, "AdminEmailOnErrors", "True" ) )
	sAdminEmailSubject = GetIniInfo( INISection, "AdminEmailSubject", "QGateway-ERROR: Kunden-Auftrag konnte nicht angelegt werden" )
	sCallAgent = GetIniInfo( INISection, "CallAgent", "1" )  
	sDefaultAK = GetIniInfo( INISection, "DefaultAK", "1" ) 
	sDefaultGewerk = GetIniInfo( INISection, "DefaultGewerk", "1" ) 
	sDefaultProzess = GetIniInfo( INISection, "DefaultProzess", "1" ) 

	Set iNetwork = iApp.CreateNetwork( "f_ut_callmanage", "f_ut_callmanage" )
	Set iCustCallTbl = iNetwork.GetTable( "custcall" )
	Set iCallTbl = iNetwork.GetTable( "call" )
End Sub
'-------------------------------------------------------------------------
Sub ClearNetwork


		iCustCallTbl.Clear
		iCustCallTbl.QBEClear
		iCallTbl.Clear
		iCallTbl.QBEClear

Exit Sub
On Error GoTo error_handler
Error_handler:
	WriteLog 1, "Clear Network ist fehlgeschlagen"	
End Sub
'-------------------------------------------------------------------------

Sub CustomerCall()
Dim i As Integer
Dim sKeyList() As String
Dim nRecs As Integer
Dim bNewErrors As Boolean
Dim nError As Integer
	On Error GoTo Error_handler
' For Tasks
	bResult = True
	Initialize 

	' Alle möglichen Tasks suchen task.resolved_extsystem=1 
	iCustCallTbl.MaxRecords = -1 ' System Maximum
	iCustCallTbl.Clear
	iCustCallTbl.QBEClear
	iCustCallTbl.QBESetValue "error","Nein"
	iCustCallTbl.Search
	nRecs =	iCustCallTbl.RecordCount
	bNewErrors = False
	' alle Keys sammeln damit ich später die Record einzeln bearbeiten kann
	' falls ein Commit fehlschlägt
	For i =1 To nRecs
		ReDim Preserve sKeyList(i-1)
		sKeyList(i-1) = iCustCallTbl.GetRecord(i-1).GetValue("pkey")
	Next i
	For i = 1 To nRecs
		ClearNetwork
		WriteLog 3, " Debug Script try custcall : "	& sKeyList(i-1)
		If Not CreateCall(sKeyList(i-1)) Then
			bNewErrors = true
			WriteLog 1, "Custcall pkey=" & sKeyList(i-1) & " konnte nicht gespeichert werden."	
		End If
	Next i
	If bAdminEmailOnErrors And bNewErrors Then SendAdminEmail 
	
Exit_sub:

	
    If Not SetAppProfileValue(iNetwork,"last_custcall","now") Then WriteLog 1, "Unable to write Timestamp"
	WriteLog 3, "Script Terminated"
	' clean up
		iCustCallTbl.Clear
	Set iCustCallTbl = Nothing
	Set iCustCallRec = Nothing
	Set iCallTbl = Nothing
	Set iCallRec = Nothing
	Set iNetwork = Nothing
	Set iApp = Nothing

	Exit Sub

Error_handler:
	nError = Err.Number
	On Error Resume Next
	LogError "CustomerCall error", nError
	GoTo Exit_sub
End Sub
























']]
