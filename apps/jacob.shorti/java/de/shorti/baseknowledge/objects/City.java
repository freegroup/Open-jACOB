package de.shorti.baseknowledge.objects;

/**
 * short-i Class generated by automatic ClassGenerator
 * Date: Wed Mar 14 14:59:41 GMT+01:00 2001
 */
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Iterator;

import de.shorti.util.basic.TraceDispatcher;
import de.shorti.util.basic.TraceFactory;

public class City extends _dbCity
{
	static TraceDispatcher  trace = TraceFactory.getTraceDispatcher();

	/**
	 *  Method:      findByNameAndState(String _name, _dbState _state)
	 *  Description:
	 *  Returns:     ArrayList<City>
	 */
	public static ArrayList findByNameAndState(String _name, _dbState _state)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("City.findByNameAndState");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT state_id, name, id FROM City WHERE name='"+_name+"' AND state_id="+((_state==null)?"''":("'"+_state.getId()+"'")));
				while(s.next())
				{
					City newObject = new City();
					newObject.state_id=s.getString(1);
					newObject.name=s.getString(2);
					newObject.id=s.getString(3);
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
                trace.error(exc);
			}
			stmt.close();

		}
		catch (Exception ex)
		{
            trace.error(ex);
        }
		return result;
	}

	/**
	 *  Method:      findByNameAndCountry(String _name, _dbCountry _country)
	 *  Description:
	 *  Returns:     ArrayList<City>
	 */
	public static ArrayList findByNameAndCountry(String _name, _dbCountry _country)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("City.findByNameAndCountry");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT city.state_id, city.name, city.id FROM city, state WHERE city.name='"+_name+"' AND city.state_id=state.id AND state.country_id='"+_country.getId()+"'");
				while(s.next())
				{
					City newObject = new City();
					newObject.state_id=s.getString(1);
					newObject.name=s.getString(2);
					newObject.id=s.getString(3);
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
                trace.error(exc);
			}
			stmt.close();

		}
		catch (Exception ex)
		{
            trace.error(ex);
		}
		return result;
	}


	/**
	 *  Method:      findById(String _id)
	 *  Description:
	 *  Returns:     City
	 */
	public static City findByNameAndDialprefix(String _name, String _dial)
	{
		City result = null;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbCity.findById");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT state_id, name,  id FROM City WHERE name='"+_name+"' AND dialPrefix='"+_dial+"' order by generatedId desc");
				if(s.next())
				{
					result = new City();
					result.state_id= s.getString(1);
					result.name= s.getString(2);
					result.id= s.getString(3);
				}
			}
			catch(Exception exc)
			{
				trace.error(exc);
			}
			stmt.close();

		}
		catch (Exception ex)
		{
			trace.error(ex);
		}
		return result;
	}

    /**
     * returns the center ZipCode of the city
     */
    public ZipCode getBestCenterZipCode()
    {
        double longitude = 0.0;
        double latitude  = 0.0;
        ArrayList result = getZipCodes();
        ZipCode resultZip=null;
        double  currentDistance = Double.MAX_VALUE;

        if(result.size()>0)
        {
            Iterator iter = result.iterator();
            while(iter.hasNext() )
            {
                ZipCode zip = (ZipCode)iter.next();
                longitude = longitude + zip.getLongitude();
                latitude  = latitude  + zip.getLatitude();
            }
            latitude  = latitude/result.size();
            longitude = longitude / result.size();
            // find the best ZipCode in the result Set
            iter= result.iterator();
            while(iter.hasNext() )
            {
                ZipCode zip = (ZipCode)iter.next();
                if(zip.getDistance(latitude, longitude)<currentDistance)
                {
                    currentDistance = zip.getDistance(latitude, longitude);
                    resultZip = zip;
                }
            }

        }
        return resultZip;
    }
}
