package de.shorti.baseknowledge.objects;

/**
 * Class generated by automatic ClassGenerator
 * Date: Sat May 11 21:15:21 GMT+02:00 2002
 */
import de.shorti.db.*;
import java.util.ArrayList;
import java.util.Iterator;
import java.sql.*;

class _dbAppointment extends dbObject 
{

	boolean   markedForDelete;
	long      duration;
	String    location;
	long      meetingStatus;
	int       isPrivate;
	int       remiderSet;
	long      start;
	String    subject;
	String    startRecurrencePattern;
	int       onlineMeeting;
	int       allDayEvent;
	String    foreignAppointmentId;
	long      creationTime;
	int       importance;
	String    endRecurrencePattern;
	long      reminderMinutesBeforeStart;
	int       recurrenceType;
	String    calendar_id;	// Foreign Key pointing to Table [Calendar], Field [id]
	String    scopeId;


	/**
	 * destroy a object in the database
	 */
	public boolean destroy()
	{
		boolean result = false;
		String    _key   = id;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.destroyInstance");
			try
			{
					stmt.executeUpdate( "DELETE FROM Appointment WHERE id='"+_key+"'");
					result = true;
					removeFromCache(this);
					id     = null;
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}



	/**
	 * Method:      getMarkedForDelete()
	 * Description: 
	 * Returns:     boolean
	 */
	public boolean getMarkedForDelete()
	{
		return markedForDelete;
	}

	/**
	 * Method:      setMarkedForDelete(boolean _markedForDelete, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setMarkedForDelete(boolean _markedForDelete, boolean _autoCommit)
	{
		markedForDelete=_markedForDelete;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getDuration()
	 * Description: 
	 * Returns:     long
	 */
	public long getDuration()
	{
		return duration;
	}

	/**
	 * Method:      setDuration(long _duration, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setDuration(long _duration, boolean _autoCommit)
	{
		duration=_duration;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getLocation()
	 * Description: 
	 * Returns:     String
	 */
	public String getLocation()
	{
		return location;
	}

	/**
	 * Method:      setLocation(String _location, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setLocation(String _location, boolean _autoCommit)
	{
		location=_location;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getMeetingStatus()
	 * Description: 
	 * Returns:     long
	 */
	public long getMeetingStatus()
	{
		return meetingStatus;
	}

	/**
	 * Method:      setMeetingStatus(long _meetingStatus, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setMeetingStatus(long _meetingStatus, boolean _autoCommit)
	{
		meetingStatus=_meetingStatus;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getIsPrivate()
	 * Description: 
	 * Returns:     int
	 */
	public int getIsPrivate()
	{
		return isPrivate;
	}

	/**
	 * Method:      setIsPrivate(int _isPrivate, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setIsPrivate(int _isPrivate, boolean _autoCommit)
	{
		isPrivate=_isPrivate;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getRemiderSet()
	 * Description: 
	 * Returns:     int
	 */
	public int getRemiderSet()
	{
		return remiderSet;
	}

	/**
	 * Method:      setRemiderSet(int _remiderSet, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setRemiderSet(int _remiderSet, boolean _autoCommit)
	{
		remiderSet=_remiderSet;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getStart()
	 * Description: 
	 * Returns:     long
	 */
	public long getStart()
	{
		return start;
	}

	/**
	 * Method:      setStart(long _start, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setStart(long _start, boolean _autoCommit)
	{
		start=_start;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getSubject()
	 * Description: 
	 * Returns:     String
	 */
	public String getSubject()
	{
		return subject;
	}

	/**
	 * Method:      setSubject(String _subject, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setSubject(String _subject, boolean _autoCommit)
	{
		subject=_subject;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getStartRecurrencePattern()
	 * Description: 
	 * Returns:     String
	 */
	public String getStartRecurrencePattern()
	{
		return startRecurrencePattern;
	}

	/**
	 * Method:      setStartRecurrencePattern(String _startRecurrencePattern, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setStartRecurrencePattern(String _startRecurrencePattern, boolean _autoCommit)
	{
		startRecurrencePattern=_startRecurrencePattern;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getOnlineMeeting()
	 * Description: 
	 * Returns:     int
	 */
	public int getOnlineMeeting()
	{
		return onlineMeeting;
	}

	/**
	 * Method:      setOnlineMeeting(int _onlineMeeting, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setOnlineMeeting(int _onlineMeeting, boolean _autoCommit)
	{
		onlineMeeting=_onlineMeeting;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getAllDayEvent()
	 * Description: 
	 * Returns:     int
	 */
	public int getAllDayEvent()
	{
		return allDayEvent;
	}

	/**
	 * Method:      setAllDayEvent(int _allDayEvent, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setAllDayEvent(int _allDayEvent, boolean _autoCommit)
	{
		allDayEvent=_allDayEvent;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getForeignAppointmentId()
	 * Description: 
	 * Returns:     String
	 */
	public String getForeignAppointmentId()
	{
		return foreignAppointmentId;
	}

	/**
	 * Method:      setForeignAppointmentId(String _foreignAppointmentId, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setForeignAppointmentId(String _foreignAppointmentId, boolean _autoCommit)
	{
		foreignAppointmentId=_foreignAppointmentId;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getCreationTime()
	 * Description: 
	 * Returns:     long
	 */
	public long getCreationTime()
	{
		return creationTime;
	}

	/**
	 * Method:      setCreationTime(long _creationTime, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setCreationTime(long _creationTime, boolean _autoCommit)
	{
		creationTime=_creationTime;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getImportance()
	 * Description: 
	 * Returns:     int
	 */
	public int getImportance()
	{
		return importance;
	}

	/**
	 * Method:      setImportance(int _importance, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setImportance(int _importance, boolean _autoCommit)
	{
		importance=_importance;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getId()
	 * Description: 
	 * Returns:     String
	 */
	public String getId()
	{
		return id;
	}

	/**
	 * Method:      getEndRecurrencePattern()
	 * Description: 
	 * Returns:     String
	 */
	public String getEndRecurrencePattern()
	{
		return endRecurrencePattern;
	}

	/**
	 * Method:      setEndRecurrencePattern(String _endRecurrencePattern, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setEndRecurrencePattern(String _endRecurrencePattern, boolean _autoCommit)
	{
		endRecurrencePattern=_endRecurrencePattern;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getReminderMinutesBeforeStart()
	 * Description: 
	 * Returns:     long
	 */
	public long getReminderMinutesBeforeStart()
	{
		return reminderMinutesBeforeStart;
	}

	/**
	 * Method:      setReminderMinutesBeforeStart(long _reminderMinutesBeforeStart, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setReminderMinutesBeforeStart(long _reminderMinutesBeforeStart, boolean _autoCommit)
	{
		reminderMinutesBeforeStart=_reminderMinutesBeforeStart;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getRecurrenceType()
	 * Description: 
	 * Returns:     int
	 */
	public int getRecurrenceType()
	{
		return recurrenceType;
	}

	/**
	 * Method:      setRecurrenceType(int _recurrenceType, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setRecurrenceType(int _recurrenceType, boolean _autoCommit)
	{
		recurrenceType=_recurrenceType;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getScopeId()
	 * Description: 
	 * Returns:     String
	 */
	public String getScopeId()
	{
		return scopeId;
	}

	/**
	 * Method:      setScopeId(String _scopeId, boolean _autoCommit)
	 * Description: 
	 * Returns:     void
	 */
	public void setScopeId(String _scopeId, boolean _autoCommit)
	{
		scopeId=_scopeId;
		if(_autoCommit)
		{
			commit();
		}
	}

	/**
	 * Method:      getCalendar()
	 * Description: 
	 * Returns:     Calendar
	 */
	public Calendar getCalendar()
	{
		return Calendar.findById(calendar_id);
	}

	/**
	 * Method:      setCalendar()
	 * Description: 
	 * Returns:     void
	 */
	public void setCalendar(Calendar _foreigner, boolean _autocommit)
	{
		calendar_id= _foreigner.getId();
		if (_autocommit == true)
			commit();
	}

	/**
	 *  Method:      findByMarkedForDelete(boolean _markedForDelete)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByMarkedForDelete(boolean _markedForDelete)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByMarkedForDelete");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE markedForDelete="+toSQL(_markedForDelete)+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByDuration(long _duration)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByDuration(long _duration)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByDuration");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE duration="+_duration+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByLocation(String _location)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByLocation(String _location)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByLocation");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE location='"+toSQL(_location)+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByMeetingStatus(long _meetingStatus)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByMeetingStatus(long _meetingStatus)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByMeetingStatus");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE meetingStatus="+_meetingStatus+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByIsPrivate(int _isPrivate)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByIsPrivate(int _isPrivate)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByIsPrivate");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE isPrivate="+_isPrivate+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByRemiderSet(int _remiderSet)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByRemiderSet(int _remiderSet)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByRemiderSet");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE remiderSet="+_remiderSet+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByStart(long _start)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByStart(long _start)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByStart");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE start="+_start+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findBySubject(String _subject)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findBySubject(String _subject)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findBySubject");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE subject='"+toSQL(_subject)+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByStartRecurrencePattern(String _startRecurrencePattern)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByStartRecurrencePattern(String _startRecurrencePattern)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByStartRecurrencePattern");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE startRecurrencePattern='"+toSQL(_startRecurrencePattern)+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByOnlineMeeting(int _onlineMeeting)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByOnlineMeeting(int _onlineMeeting)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByOnlineMeeting");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE onlineMeeting="+_onlineMeeting+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByAllDayEvent(int _allDayEvent)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByAllDayEvent(int _allDayEvent)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByAllDayEvent");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE allDayEvent="+_allDayEvent+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByForeignAppointmentId(String _foreignAppointmentId)
	 *  Description: 
	 *  Returns:     Appointment
	 */
	public static Appointment findByForeignAppointmentId(String _foreignAppointmentId)
	{
		Appointment result = null;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByForeignAppointmentId");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE foreignAppointmentId='"+toSQL(_foreignAppointmentId)+"'"+" order by generatedId desc");
				if(s.next())
				{
					String _tmpID = s.getString(1);
					result = (Appointment)getFromCache(_tmpID);
					if(result ==null)
					{
						result = new Appointment();
						result.markedForDelete= s.getBoolean(2);
						result.duration= s.getLong(3);
						result.location= s.getString(4);
						result.meetingStatus= s.getLong(5);
						result.isPrivate= s.getInt(6);
						result.remiderSet= s.getInt(7);
						result.start= s.getLong(8);
						result.subject= s.getString(9);
						result.startRecurrencePattern= s.getString(10);
						result.onlineMeeting= s.getInt(11);
						result.allDayEvent= s.getInt(12);
						result.foreignAppointmentId= s.getString(13);
						result.creationTime= s.getLong(14);
						result.importance= s.getInt(15);
						result.id= _tmpID;
						result.endRecurrencePattern= s.getString(16);
						result.reminderMinutesBeforeStart= s.getLong(17);
						result.recurrenceType= s.getInt(18);
						result.calendar_id= s.getString(19);
						result.scopeId= s.getString(20);
						putToCache(result);
					}
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByCreationTime(long _creationTime)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByCreationTime(long _creationTime)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByCreationTime");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE creationTime="+_creationTime+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByImportance(int _importance)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByImportance(int _importance)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByImportance");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE importance="+_importance+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findById(String _id)
	 *  Description: 
	 *  Returns:     Appointment
	 */
	public static Appointment findById(String _id)
	{
		Appointment result = (Appointment)getFromCache(_id);
		if(result!=null) return result;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findById");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE id='"+toSQL(_id)+"'"+" order by generatedId desc");
				if(s.next())
				{
					result = new Appointment();
					result.markedForDelete= s.getBoolean(2);
					result.duration= s.getLong(3);
					result.location= s.getString(4);
					result.meetingStatus= s.getLong(5);
					result.isPrivate= s.getInt(6);
					result.remiderSet= s.getInt(7);
					result.start= s.getLong(8);
					result.subject= s.getString(9);
					result.startRecurrencePattern= s.getString(10);
					result.onlineMeeting= s.getInt(11);
					result.allDayEvent= s.getInt(12);
					result.foreignAppointmentId= s.getString(13);
					result.creationTime= s.getLong(14);
					result.importance= s.getInt(15);
					result.id= _id;
					result.endRecurrencePattern= s.getString(16);
					result.reminderMinutesBeforeStart= s.getLong(17);
					result.recurrenceType= s.getInt(18);
					result.calendar_id= s.getString(19);
					result.scopeId= s.getString(20);
					putToCache(result);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByEndRecurrencePattern(String _endRecurrencePattern)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByEndRecurrencePattern(String _endRecurrencePattern)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByEndRecurrencePattern");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE endRecurrencePattern='"+toSQL(_endRecurrencePattern)+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByReminderMinutesBeforeStart(long _reminderMinutesBeforeStart)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByReminderMinutesBeforeStart(long _reminderMinutesBeforeStart)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByReminderMinutesBeforeStart");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE reminderMinutesBeforeStart="+_reminderMinutesBeforeStart+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByRecurrenceType(int _recurrenceType)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByRecurrenceType(int _recurrenceType)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByRecurrenceType");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE recurrenceType="+_recurrenceType+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByCalendar(_dbCalendar _calendar)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByCalendar(_dbCalendar _calendar)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByCalendar");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE calendar_id='"+toSQL(((_calendar==null)?"":_calendar.getId()))+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 *  Method:      findByScopeId(String _scopeId)
	 *  Description: 
	 *  Returns:     ArrayList<Appointment>
	 */
	public static ArrayList findByScopeId(String _scopeId)
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.findByScopeId");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment WHERE scopeId='"+toSQL(_scopeId)+"'"+" order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}

	/**
	 * returns boolean
	 */
	public boolean commit()
	{
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.commit");
			try
			{
				stmt.executeUpdate( "UPDATE Appointment set markedForDelete= "+toSQL(markedForDelete)+", duration= "+duration+", location= '"+toSQL(location)+"', meetingStatus= "+meetingStatus+", isPrivate= "+isPrivate+", remiderSet= "+remiderSet+", start= "+start+", subject= '"+toSQL(subject)+"', startRecurrencePattern= '"+toSQL(startRecurrencePattern)+"', onlineMeeting= "+onlineMeeting+", allDayEvent= "+allDayEvent+", foreignAppointmentId= '"+toSQL(foreignAppointmentId)+"', creationTime= "+creationTime+", importance= "+importance+", endRecurrencePattern= '"+toSQL(endRecurrencePattern)+"', reminderMinutesBeforeStart= "+reminderMinutesBeforeStart+", recurrenceType= "+recurrenceType+", calendar_id= '"+toSQL(calendar_id)+"', scopeId= '"+toSQL(scopeId)+"' WHERE id='"+id+"'");
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return true;
	}


	/**
	 * returns ArrayList<Appointment>
	 */
	public static ArrayList getAll()
	{
		ArrayList result = new ArrayList();
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.getAll");
			try
			{
				ResultSet s = stmt.executeQuery( "SELECT id, markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId FROM Appointment order by generatedId desc");
				while(s.next())
				{
					String _tmpID = s.getString(1);
					Appointment newObject = (Appointment)getFromCache(_tmpID);
					if(newObject ==null)
					{
						newObject = new Appointment();
						newObject.markedForDelete=s.getBoolean(2);
						newObject.duration=s.getLong(3);
						newObject.location=s.getString(4);
						newObject.meetingStatus=s.getLong(5);
						newObject.isPrivate=s.getInt(6);
						newObject.remiderSet=s.getInt(7);
						newObject.start=s.getLong(8);
						newObject.subject=s.getString(9);
						newObject.startRecurrencePattern=s.getString(10);
						newObject.onlineMeeting=s.getInt(11);
						newObject.allDayEvent=s.getInt(12);
						newObject.foreignAppointmentId=s.getString(13);
						newObject.creationTime=s.getLong(14);
						newObject.importance=s.getInt(15);
						newObject.id=_tmpID;
						newObject.endRecurrencePattern=s.getString(16);
						newObject.reminderMinutesBeforeStart=s.getLong(17);
						newObject.recurrenceType=s.getInt(18);
						newObject.calendar_id=s.getString(19);
						newObject.scopeId=s.getString(20);
						putToCache(newObject);
					}
					result.add(newObject);
				}
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}


	/**
	 * create a new object in the database
	 */
	static public Appointment createInstance( boolean  _markedForDelete, long  _duration, String  _location, long  _meetingStatus, int  _isPrivate, int  _remiderSet, long  _start, String  _subject, String  _startRecurrencePattern, int  _onlineMeeting, int  _allDayEvent, String  _foreignAppointmentId, long  _creationTime, int  _importance, String  _endRecurrencePattern, long  _reminderMinutesBeforeStart, int  _recurrenceType, _dbCalendar _calendar, String  _scopeId )
	{
		Appointment result = null;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.createInstance");
			try
			{
				String nextGUID = new java.rmi.server.UID().toString();
				stmt.executeUpdate( "INSERT INTO Appointment ( markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, id, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId) VALUES ("+toSQL(_markedForDelete)+", "+_duration+",  '"+toSQL(_location)+"', "+_meetingStatus+", "+_isPrivate+", "+_remiderSet+", "+_start+",  '"+toSQL(_subject)+"',  '"+toSQL(_startRecurrencePattern)+"', "+_onlineMeeting+", "+_allDayEvent+",  '"+toSQL(_foreignAppointmentId)+"', "+_creationTime+", "+_importance+", '"+nextGUID+"',  '"+toSQL(_endRecurrencePattern)+"', "+_reminderMinutesBeforeStart+", "+_recurrenceType+",  '"+((_calendar==null)?"":_calendar.getId())+"',  '"+toSQL(_scopeId)+"')");
				result = new Appointment();
				result.markedForDelete= _markedForDelete;
				result.duration= _duration;
				result.location= _location;
				result.meetingStatus= _meetingStatus;
				result.isPrivate= _isPrivate;
				result.remiderSet= _remiderSet;
				result.start= _start;
				result.subject= _subject;
				result.startRecurrencePattern= _startRecurrencePattern;
				result.onlineMeeting= _onlineMeeting;
				result.allDayEvent= _allDayEvent;
				result.foreignAppointmentId= _foreignAppointmentId;
				result.creationTime= _creationTime;
				result.importance= _importance;
				result.id= nextGUID;
				result.endRecurrencePattern= _endRecurrencePattern;
				result.reminderMinutesBeforeStart= _reminderMinutesBeforeStart;
				result.recurrenceType= _recurrenceType;
				result.calendar_id= (_calendar==null)?"":_calendar.getId();
				result.scopeId= _scopeId;
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}


	/**
	 * create a new object in the database
	 */
	static public void newInstance( boolean  _markedForDelete, long  _duration, String  _location, long  _meetingStatus, int  _isPrivate, int  _remiderSet, long  _start, String  _subject, String  _startRecurrencePattern, int  _onlineMeeting, int  _allDayEvent, String  _foreignAppointmentId, long  _creationTime, int  _importance, String  _endRecurrencePattern, long  _reminderMinutesBeforeStart, int  _recurrenceType, _dbCalendar _calendar, String  _scopeId )
	{
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.newInstance");
			try
			{
				String nextGUID = new java.rmi.server.UID().toString();
				stmt.executeUpdate( "INSERT INTO Appointment ( markedForDelete, duration, location, meetingStatus, isPrivate, remiderSet, start, subject, startRecurrencePattern, onlineMeeting, allDayEvent, foreignAppointmentId, creationTime, importance, id, endRecurrencePattern, reminderMinutesBeforeStart, recurrenceType, calendar_id, scopeId) VALUES ("+toSQL(_markedForDelete)+", "+_duration+",  '"+toSQL(_location)+"', "+_meetingStatus+", "+_isPrivate+", "+_remiderSet+", "+_start+",  '"+toSQL(_subject)+"',  '"+toSQL(_startRecurrencePattern)+"', "+_onlineMeeting+", "+_allDayEvent+",  '"+toSQL(_foreignAppointmentId)+"', "+_creationTime+", "+_importance+", '"+nextGUID+"',  '"+toSQL(_endRecurrencePattern)+"', "+_reminderMinutesBeforeStart+", "+_recurrenceType+",  '"+((_calendar==null)?"":_calendar.getId())+"',  '"+toSQL(_scopeId)+"')");
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
	}


	/**
	 * destroy a object in the database
	 */
	static public boolean destroyInstance( String  _key)
	{
		boolean result = false;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.destroyInstance");
			try
			{
					stmt.executeUpdate( "DELETE FROM Appointment WHERE id='"+_key+"'");
					result = true;
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}


	/**
	 * destroy ALL objects in the database
	 */
	static public boolean destroyAll()
	{
		boolean result = false;
		SaveStatement  stmt;

		try
		{
			stmt  = ConnectionManager.getValid().createStatement("_dbAppointment.destroyAll");
			try
			{
					stmt.executeUpdate("DELETE from Appointment" );
					result = true;
			}
			catch(Exception exc)
			{
				System.err.println(exc);
				exc.printStackTrace();
			}
			stmt.close();
		
		}
		catch (Exception ex)
		{
			System.err.println(ex);
			ex.printStackTrace();
		}
		return result;
	}


	/**
	 */
	public String toString()
	{
		StringBuffer result = new StringBuffer(1024);
		result.append(markedForDelete);
		result.append("|");
		result.append(duration);
		result.append("|");
		result.append(location);
		result.append("|");
		result.append(meetingStatus);
		result.append("|");
		result.append(isPrivate);
		result.append("|");
		result.append(remiderSet);
		result.append("|");
		result.append(start);
		result.append("|");
		result.append(subject);
		result.append("|");
		result.append(startRecurrencePattern);
		result.append("|");
		result.append(onlineMeeting);
		result.append("|");
		result.append(allDayEvent);
		result.append("|");
		result.append(foreignAppointmentId);
		result.append("|");
		result.append(creationTime);
		result.append("|");
		result.append(importance);
		result.append("|");
		result.append(id);
		result.append("|");
		result.append(endRecurrencePattern);
		result.append("|");
		result.append(reminderMinutesBeforeStart);
		result.append("|");
		result.append(recurrenceType);
		result.append("|");
		result.append(calendar_id);
		result.append("|");
		result.append(scopeId);
		return result.toString();
	}


	/**
	 * init the class
	 */
	static
	{
		try
		{
			DatabaseMetaData dMeta = ConnectionManager.getValid().getMetaData ();
			ResultSet result;
			result=dMeta.getColumns(null,null,"Appointment","markedForDelete");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'markedForDelete' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","duration");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'duration' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","location");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'location' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","meetingStatus");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'meetingStatus' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","isPrivate");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'isPrivate' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","remiderSet");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'remiderSet' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","start");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'start' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","subject");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'subject' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","startRecurrencePattern");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'startRecurrencePattern' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","onlineMeeting");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'onlineMeeting' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","allDayEvent");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'allDayEvent' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","foreignAppointmentId");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'foreignAppointmentId' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","creationTime");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'creationTime' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","importance");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'importance' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","id");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'id' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","endRecurrencePattern");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'endRecurrencePattern' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","reminderMinutesBeforeStart");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'reminderMinutesBeforeStart' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","recurrenceType");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'recurrenceType' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","calendar_id");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'calendar_id' in table 'Appointment' missing");
			}
			result.close();
			result=dMeta.getColumns(null,null,"Appointment","scopeId");
			if(!result.next())
			{
				System.out.println("ERROR: installed DB-schema not compatible to java classes");
				System.out.println("       Attribute 'scopeId' in table 'Appointment' missing");
			}
			result.close();
		}
		catch (Exception ex)
		{
		}
	}


}
